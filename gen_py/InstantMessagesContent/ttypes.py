# -*- coding: utf-8 -*-
#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from gen_py import Common
import gen_py.Common.ttypes
import gen_py.StaticStorageWorker.ttypes
import gen_py.InstantMessagesContentConstants.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None



class TextContentDto:
  """
   * Текст сообщения
  *

  Attributes:
   - text
   - locale
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'text', None, None, ), # 1
    (2, TType.STRING, 'locale', None, None, ), # 2
  )

  def __init__(self, text=None, locale=None,):
    self.text = text
    self.locale = locale

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.text = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.locale = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TextContentDto')
    if self.text is not None:
      oprot.writeFieldBegin('text', TType.STRING, 1)
      oprot.writeString(self.text)
      oprot.writeFieldEnd()
    if self.locale is not None:
      oprot.writeFieldBegin('locale', TType.STRING, 2)
      oprot.writeString(self.locale)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DealContentDto:
  """
   * Контент сделки, содержит в себе информацию с ценой и количеством штук товара.
   * Имеются разные типы контентов (оффер, аксепт итд)
  *

  Attributes:
   - wareId
   - count
   - pricePerUnit
   - contentType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'wareId', None, None, ), # 1
    (2, TType.I32, 'count', None, None, ), # 2
    (3, TType.STRUCT, 'pricePerUnit', (Common.ttypes.CurrencyAmount, Common.ttypes.CurrencyAmount.thrift_spec), None, ), # 3
    (4, TType.I32, 'contentType', None, None, ), # 4
  )

  def __init__(self, wareId=None, count=None, pricePerUnit=None, contentType=None,):
    self.wareId = wareId
    self.count = count
    self.pricePerUnit = pricePerUnit
    self.contentType = contentType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.wareId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.count = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.pricePerUnit = Common.ttypes.CurrencyAmount()
          self.pricePerUnit.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.contentType = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DealContentDto')
    if self.wareId is not None:
      oprot.writeFieldBegin('wareId', TType.STRING, 1)
      oprot.writeString(self.wareId)
      oprot.writeFieldEnd()
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.I32, 2)
      oprot.writeI32(self.count)
      oprot.writeFieldEnd()
    if self.pricePerUnit is not None:
      oprot.writeFieldBegin('pricePerUnit', TType.STRUCT, 3)
      self.pricePerUnit.write(oprot)
      oprot.writeFieldEnd()
    if self.contentType is not None:
      oprot.writeFieldBegin('contentType', TType.I32, 4)
      oprot.writeI32(self.contentType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ContentItemDto:
  """
   * Пункт сообщения: под_сообщение
  *

  Attributes:
   - contentType:  * Тип сообщения
  *
   - text:  * В зависимости от тип содержимого должно быть заполнено одно из нижележащих полей.
   * Например если contentType равен TEXT то поле text должно обязательно быть заполнено. Аналогично для других полей
  *
   - pictureId
   - userId
   - dealContent
   - wareId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'contentType', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.STRUCT, 'text', (TextContentDto, TextContentDto.thrift_spec), None, ), # 10
    (11, TType.STRING, 'pictureId', None, None, ), # 11
    (12, TType.I32, 'userId', None, None, ), # 12
    (13, TType.STRUCT, 'dealContent', (DealContentDto, DealContentDto.thrift_spec), None, ), # 13
    (14, TType.STRING, 'wareId', None, None, ), # 14
  )

  def __init__(self, contentType=None, text=None, pictureId=None, userId=None, dealContent=None, wareId=None,):
    self.contentType = contentType
    self.text = text
    self.pictureId = pictureId
    self.userId = userId
    self.dealContent = dealContent
    self.wareId = wareId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.contentType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.text = TextContentDto()
          self.text.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.pictureId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I32:
          self.userId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          self.dealContent = DealContentDto()
          self.dealContent.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRING:
          self.wareId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ContentItemDto')
    if self.contentType is not None:
      oprot.writeFieldBegin('contentType', TType.I32, 1)
      oprot.writeI32(self.contentType)
      oprot.writeFieldEnd()
    if self.text is not None:
      oprot.writeFieldBegin('text', TType.STRUCT, 10)
      self.text.write(oprot)
      oprot.writeFieldEnd()
    if self.pictureId is not None:
      oprot.writeFieldBegin('pictureId', TType.STRING, 11)
      oprot.writeString(self.pictureId)
      oprot.writeFieldEnd()
    if self.userId is not None:
      oprot.writeFieldBegin('userId', TType.I32, 12)
      oprot.writeI32(self.userId)
      oprot.writeFieldEnd()
    if self.dealContent is not None:
      oprot.writeFieldBegin('dealContent', TType.STRUCT, 13)
      self.dealContent.write(oprot)
      oprot.writeFieldEnd()
    if self.wareId is not None:
      oprot.writeFieldBegin('wareId', TType.STRING, 14)
      oprot.writeString(self.wareId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
