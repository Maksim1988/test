# -*- coding: utf-8 -*-
#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from gen_py import Exceptions
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  """
   * Создание диалогов, сделок, посылки сообщений, получения истории сообщений и т.д.
   *
   * Апи мессаджинга. Подсистема мессаджинга соотоит из следующих сущностей:
   *  - диалог, содержит список идентификатором пользователей и сообщений
   *  - сообщение, содержит список идентификаторов получателей сообщения и статус - прочитано ли это сообщений пользователем
   *  - список диалогов пользователя
   *  - диалог пользователя - время последнего прочитанного пользователем сообщения в диалоге
  *
  """
  def markMessagesAsRead(self, request):
    """
    Parameters:
     - request
    """
    pass

  def markDialogAsRead(self, request):
    """
    Parameters:
     - request
    """
    pass

  def getMessageHistory(self, request):
    """
    Parameters:
     - request
    """
    pass

  def getChatWithUser(self, ownerId, opponentId):
    """
     * Получить информацию по диалогу пользователя с другим пользователем.
     * Между двумя пользователями может существовавть только один чат.
     * НО у каждого юзера своя копия чата, чтобы юзер мог свой чат заархивировать например
     * а у второго юзера чат остался в том же состоянии как и был
     *
     * NullResultException - если чат не найден
    *

    Parameters:
     - ownerId
     - opponentId
    """
    pass

  def getDealById(self, dealId, ownerId):
    """
    Parameters:
     - dealId
     - ownerId
    """
    pass

  def sendChatMessageToUser(self, message, opponentId):
    """
     * Послать сообщение юзеру и создать чат если его не существует
     *  - Если при посылке произошли внутренние ошибки то будет  выброшено UnavailableException.
     *  - На некорректный запрос бужет выброшено BadRequestException.
     *  - Если сообщение будет послано в несуществующий диалог то будет выброшено NoSuchResourceException.
     *  - Ошибки посылки сообщения SendMessageException
    *

    Parameters:
     - message
     - opponentId
    """
    pass

  def getConversationsByUser(self, request):
    """
     * Получить все "разговоры" (conversations) пользователя. Conversation это чаты и сделки пользователя, так как
     * и те и другие являются в конечном счете диалогами.
     * В ответ будет послан список диалогов сгруппированных по пользователю. Список будет отсортирован по времени последнего
     * добавленного сообщения в диалоге.
    *

    Parameters:
     - request
    """
    pass

  def getUnreadReport(self, ownerId):
    """
    Parameters:
     - ownerId
    """
    pass

  def getUserDeals(self, request):
    """
     * Получить все сделочные диалоги по товару
    *

    Parameters:
     - request
    """
    pass

  def getDealsWithUser(self, request):
    """
     * Получить сделочные диалоги с данным оппонентом
    *

    Parameters:
     - request
    """
    pass

  def sendDealMessage(self, message, opponentId, wareId):
    """
     * Посылка сделочного сообщения
    *

    Parameters:
     - message
     - opponentId
     - wareId
    """
    pass

  def moveDealToArchive(self, dialogId, ownerId):
    """
    Parameters:
     - dialogId
     - ownerId
    """
    pass

  def getAllWaresDeal(self, userDealsByWareRequest):
    """
    Parameters:
     - userDealsByWareRequest
    """
    pass

  def getUserChats(self, filter):
    """
    Parameters:
     - filter
    """
    pass

  def findAllOpponents(self, userId):
    """
    Parameters:
     - userId
    """
    pass

  def getBuyerDeals(self, buyerId):
    """
    Parameters:
     - buyerId
    """
    pass


class Client(Iface):
  """
   * Создание диалогов, сделок, посылки сообщений, получения истории сообщений и т.д.
   *
   * Апи мессаджинга. Подсистема мессаджинга соотоит из следующих сущностей:
   *  - диалог, содержит список идентификатором пользователей и сообщений
   *  - сообщение, содержит список идентификаторов получателей сообщения и статус - прочитано ли это сообщений пользователем
   *  - список диалогов пользователя
   *  - диалог пользователя - время последнего прочитанного пользователем сообщения в диалоге
  *
  """
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def markMessagesAsRead(self, request):
    """
    Parameters:
     - request
    """
    self.send_markMessagesAsRead(request)
    self.recv_markMessagesAsRead()

  def send_markMessagesAsRead(self, request):
    self._oprot.writeMessageBegin('markMessagesAsRead', TMessageType.CALL, self._seqid)
    args = markMessagesAsRead_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_markMessagesAsRead(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = markMessagesAsRead_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.uEx is not None:
      raise result.uEx
    if result.bEx is not None:
      raise result.bEx
    if result.nEx is not None:
      raise result.nEx
    return

  def markDialogAsRead(self, request):
    """
    Parameters:
     - request
    """
    self.send_markDialogAsRead(request)
    self.recv_markDialogAsRead()

  def send_markDialogAsRead(self, request):
    self._oprot.writeMessageBegin('markDialogAsRead', TMessageType.CALL, self._seqid)
    args = markDialogAsRead_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_markDialogAsRead(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = markDialogAsRead_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.uEx is not None:
      raise result.uEx
    if result.bEx is not None:
      raise result.bEx
    if result.nEx is not None:
      raise result.nEx
    return

  def getMessageHistory(self, request):
    """
    Parameters:
     - request
    """
    self.send_getMessageHistory(request)
    return self.recv_getMessageHistory()

  def send_getMessageHistory(self, request):
    self._oprot.writeMessageBegin('getMessageHistory', TMessageType.CALL, self._seqid)
    args = getMessageHistory_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getMessageHistory(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getMessageHistory_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.uEx is not None:
      raise result.uEx
    if result.bEx is not None:
      raise result.bEx
    if result.nEx is not None:
      raise result.nEx
    if result.mEx is not None:
      raise result.mEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getMessageHistory failed: unknown result");

  def getChatWithUser(self, ownerId, opponentId):
    """
     * Получить информацию по диалогу пользователя с другим пользователем.
     * Между двумя пользователями может существовавть только один чат.
     * НО у каждого юзера своя копия чата, чтобы юзер мог свой чат заархивировать например
     * а у второго юзера чат остался в том же состоянии как и был
     *
     * NullResultException - если чат не найден
    *

    Parameters:
     - ownerId
     - opponentId
    """
    self.send_getChatWithUser(ownerId, opponentId)
    return self.recv_getChatWithUser()

  def send_getChatWithUser(self, ownerId, opponentId):
    self._oprot.writeMessageBegin('getChatWithUser', TMessageType.CALL, self._seqid)
    args = getChatWithUser_args()
    args.ownerId = ownerId
    args.opponentId = opponentId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getChatWithUser(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getChatWithUser_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.uEx is not None:
      raise result.uEx
    if result.bEx is not None:
      raise result.bEx
    if result.nEx is not None:
      raise result.nEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getChatWithUser failed: unknown result");

  def getDealById(self, dealId, ownerId):
    """
    Parameters:
     - dealId
     - ownerId
    """
    self.send_getDealById(dealId, ownerId)
    return self.recv_getDealById()

  def send_getDealById(self, dealId, ownerId):
    self._oprot.writeMessageBegin('getDealById', TMessageType.CALL, self._seqid)
    args = getDealById_args()
    args.dealId = dealId
    args.ownerId = ownerId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getDealById(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getDealById_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.uEx is not None:
      raise result.uEx
    if result.bEx is not None:
      raise result.bEx
    if result.nEx is not None:
      raise result.nEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getDealById failed: unknown result");

  def sendChatMessageToUser(self, message, opponentId):
    """
     * Послать сообщение юзеру и создать чат если его не существует
     *  - Если при посылке произошли внутренние ошибки то будет  выброшено UnavailableException.
     *  - На некорректный запрос бужет выброшено BadRequestException.
     *  - Если сообщение будет послано в несуществующий диалог то будет выброшено NoSuchResourceException.
     *  - Ошибки посылки сообщения SendMessageException
    *

    Parameters:
     - message
     - opponentId
    """
    self.send_sendChatMessageToUser(message, opponentId)
    return self.recv_sendChatMessageToUser()

  def send_sendChatMessageToUser(self, message, opponentId):
    self._oprot.writeMessageBegin('sendChatMessageToUser', TMessageType.CALL, self._seqid)
    args = sendChatMessageToUser_args()
    args.message = message
    args.opponentId = opponentId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sendChatMessageToUser(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = sendChatMessageToUser_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.uEx is not None:
      raise result.uEx
    if result.bEx is not None:
      raise result.bEx
    if result.sEx is not None:
      raise result.sEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sendChatMessageToUser failed: unknown result");

  def getConversationsByUser(self, request):
    """
     * Получить все "разговоры" (conversations) пользователя. Conversation это чаты и сделки пользователя, так как
     * и те и другие являются в конечном счете диалогами.
     * В ответ будет послан список диалогов сгруппированных по пользователю. Список будет отсортирован по времени последнего
     * добавленного сообщения в диалоге.
    *

    Parameters:
     - request
    """
    self.send_getConversationsByUser(request)
    return self.recv_getConversationsByUser()

  def send_getConversationsByUser(self, request):
    self._oprot.writeMessageBegin('getConversationsByUser', TMessageType.CALL, self._seqid)
    args = getConversationsByUser_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getConversationsByUser(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getConversationsByUser_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.uEx is not None:
      raise result.uEx
    if result.bEx is not None:
      raise result.bEx
    if result.dEx is not None:
      raise result.dEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getConversationsByUser failed: unknown result");

  def getUnreadReport(self, ownerId):
    """
    Parameters:
     - ownerId
    """
    self.send_getUnreadReport(ownerId)
    return self.recv_getUnreadReport()

  def send_getUnreadReport(self, ownerId):
    self._oprot.writeMessageBegin('getUnreadReport', TMessageType.CALL, self._seqid)
    args = getUnreadReport_args()
    args.ownerId = ownerId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getUnreadReport(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getUnreadReport_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.uEx is not None:
      raise result.uEx
    if result.bEx is not None:
      raise result.bEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getUnreadReport failed: unknown result");

  def getUserDeals(self, request):
    """
     * Получить все сделочные диалоги по товару
    *

    Parameters:
     - request
    """
    self.send_getUserDeals(request)
    return self.recv_getUserDeals()

  def send_getUserDeals(self, request):
    self._oprot.writeMessageBegin('getUserDeals', TMessageType.CALL, self._seqid)
    args = getUserDeals_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getUserDeals(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getUserDeals_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.uEx is not None:
      raise result.uEx
    if result.bEx is not None:
      raise result.bEx
    if result.dEx is not None:
      raise result.dEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getUserDeals failed: unknown result");

  def getDealsWithUser(self, request):
    """
     * Получить сделочные диалоги с данным оппонентом
    *

    Parameters:
     - request
    """
    self.send_getDealsWithUser(request)
    return self.recv_getDealsWithUser()

  def send_getDealsWithUser(self, request):
    self._oprot.writeMessageBegin('getDealsWithUser', TMessageType.CALL, self._seqid)
    args = getDealsWithUser_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getDealsWithUser(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getDealsWithUser_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.uEx is not None:
      raise result.uEx
    if result.bEx is not None:
      raise result.bEx
    if result.dEx is not None:
      raise result.dEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getDealsWithUser failed: unknown result");

  def sendDealMessage(self, message, opponentId, wareId):
    """
     * Посылка сделочного сообщения
    *

    Parameters:
     - message
     - opponentId
     - wareId
    """
    self.send_sendDealMessage(message, opponentId, wareId)
    return self.recv_sendDealMessage()

  def send_sendDealMessage(self, message, opponentId, wareId):
    self._oprot.writeMessageBegin('sendDealMessage', TMessageType.CALL, self._seqid)
    args = sendDealMessage_args()
    args.message = message
    args.opponentId = opponentId
    args.wareId = wareId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sendDealMessage(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = sendDealMessage_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.uEx is not None:
      raise result.uEx
    if result.bEx is not None:
      raise result.bEx
    if result.sEx is not None:
      raise result.sEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sendDealMessage failed: unknown result");

  def moveDealToArchive(self, dialogId, ownerId):
    """
    Parameters:
     - dialogId
     - ownerId
    """
    self.send_moveDealToArchive(dialogId, ownerId)
    return self.recv_moveDealToArchive()

  def send_moveDealToArchive(self, dialogId, ownerId):
    self._oprot.writeMessageBegin('moveDealToArchive', TMessageType.CALL, self._seqid)
    args = moveDealToArchive_args()
    args.dialogId = dialogId
    args.ownerId = ownerId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_moveDealToArchive(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = moveDealToArchive_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.uEx is not None:
      raise result.uEx
    if result.bEx is not None:
      raise result.bEx
    if result.dEx is not None:
      raise result.dEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "moveDealToArchive failed: unknown result");

  def getAllWaresDeal(self, userDealsByWareRequest):
    """
    Parameters:
     - userDealsByWareRequest
    """
    self.send_getAllWaresDeal(userDealsByWareRequest)
    return self.recv_getAllWaresDeal()

  def send_getAllWaresDeal(self, userDealsByWareRequest):
    self._oprot.writeMessageBegin('getAllWaresDeal', TMessageType.CALL, self._seqid)
    args = getAllWaresDeal_args()
    args.userDealsByWareRequest = userDealsByWareRequest
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getAllWaresDeal(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getAllWaresDeal_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.uEx is not None:
      raise result.uEx
    if result.bEx is not None:
      raise result.bEx
    if result.dEx is not None:
      raise result.dEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getAllWaresDeal failed: unknown result");

  def getUserChats(self, filter):
    """
    Parameters:
     - filter
    """
    self.send_getUserChats(filter)
    return self.recv_getUserChats()

  def send_getUserChats(self, filter):
    self._oprot.writeMessageBegin('getUserChats', TMessageType.CALL, self._seqid)
    args = getUserChats_args()
    args.filter = filter
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getUserChats(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getUserChats_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.uEx is not None:
      raise result.uEx
    if result.bEx is not None:
      raise result.bEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getUserChats failed: unknown result");

  def findAllOpponents(self, userId):
    """
    Parameters:
     - userId
    """
    self.send_findAllOpponents(userId)
    return self.recv_findAllOpponents()

  def send_findAllOpponents(self, userId):
    self._oprot.writeMessageBegin('findAllOpponents', TMessageType.CALL, self._seqid)
    args = findAllOpponents_args()
    args.userId = userId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findAllOpponents(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = findAllOpponents_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findAllOpponents failed: unknown result");

  def getBuyerDeals(self, buyerId):
    """
    Parameters:
     - buyerId
    """
    self.send_getBuyerDeals(buyerId)
    return self.recv_getBuyerDeals()

  def send_getBuyerDeals(self, buyerId):
    self._oprot.writeMessageBegin('getBuyerDeals', TMessageType.CALL, self._seqid)
    args = getBuyerDeals_args()
    args.buyerId = buyerId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getBuyerDeals(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getBuyerDeals_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.uEx is not None:
      raise result.uEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getBuyerDeals failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["markMessagesAsRead"] = Processor.process_markMessagesAsRead
    self._processMap["markDialogAsRead"] = Processor.process_markDialogAsRead
    self._processMap["getMessageHistory"] = Processor.process_getMessageHistory
    self._processMap["getChatWithUser"] = Processor.process_getChatWithUser
    self._processMap["getDealById"] = Processor.process_getDealById
    self._processMap["sendChatMessageToUser"] = Processor.process_sendChatMessageToUser
    self._processMap["getConversationsByUser"] = Processor.process_getConversationsByUser
    self._processMap["getUnreadReport"] = Processor.process_getUnreadReport
    self._processMap["getUserDeals"] = Processor.process_getUserDeals
    self._processMap["getDealsWithUser"] = Processor.process_getDealsWithUser
    self._processMap["sendDealMessage"] = Processor.process_sendDealMessage
    self._processMap["moveDealToArchive"] = Processor.process_moveDealToArchive
    self._processMap["getAllWaresDeal"] = Processor.process_getAllWaresDeal
    self._processMap["getUserChats"] = Processor.process_getUserChats
    self._processMap["findAllOpponents"] = Processor.process_findAllOpponents
    self._processMap["getBuyerDeals"] = Processor.process_getBuyerDeals

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_markMessagesAsRead(self, seqid, iprot, oprot):
    args = markMessagesAsRead_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = markMessagesAsRead_result()
    try:
      self._handler.markMessagesAsRead(args.request)
    except Exceptions.ttypes.UnavailableException, uEx:
      result.uEx = uEx
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    except Exceptions.ttypes.NoSuchResourceException, nEx:
      result.nEx = nEx
    oprot.writeMessageBegin("markMessagesAsRead", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_markDialogAsRead(self, seqid, iprot, oprot):
    args = markDialogAsRead_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = markDialogAsRead_result()
    try:
      self._handler.markDialogAsRead(args.request)
    except Exceptions.ttypes.UnavailableException, uEx:
      result.uEx = uEx
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    except Exceptions.ttypes.NoSuchResourceException, nEx:
      result.nEx = nEx
    oprot.writeMessageBegin("markDialogAsRead", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getMessageHistory(self, seqid, iprot, oprot):
    args = getMessageHistory_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getMessageHistory_result()
    try:
      result.success = self._handler.getMessageHistory(args.request)
    except Exceptions.ttypes.UnavailableException, uEx:
      result.uEx = uEx
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    except Exceptions.ttypes.NoSuchResourceException, nEx:
      result.nEx = nEx
    except Exceptions.ttypes.MalformedException, mEx:
      result.mEx = mEx
    oprot.writeMessageBegin("getMessageHistory", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getChatWithUser(self, seqid, iprot, oprot):
    args = getChatWithUser_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getChatWithUser_result()
    try:
      result.success = self._handler.getChatWithUser(args.ownerId, args.opponentId)
    except Exceptions.ttypes.UnavailableException, uEx:
      result.uEx = uEx
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    except Exceptions.ttypes.NullResultException, nEx:
      result.nEx = nEx
    oprot.writeMessageBegin("getChatWithUser", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getDealById(self, seqid, iprot, oprot):
    args = getDealById_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getDealById_result()
    try:
      result.success = self._handler.getDealById(args.dealId, args.ownerId)
    except Exceptions.ttypes.UnavailableException, uEx:
      result.uEx = uEx
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    except Exceptions.ttypes.NullResultException, nEx:
      result.nEx = nEx
    oprot.writeMessageBegin("getDealById", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sendChatMessageToUser(self, seqid, iprot, oprot):
    args = sendChatMessageToUser_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sendChatMessageToUser_result()
    try:
      result.success = self._handler.sendChatMessageToUser(args.message, args.opponentId)
    except Exceptions.ttypes.UnavailableException, uEx:
      result.uEx = uEx
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    except SendMessageException, sEx:
      result.sEx = sEx
    oprot.writeMessageBegin("sendChatMessageToUser", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getConversationsByUser(self, seqid, iprot, oprot):
    args = getConversationsByUser_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getConversationsByUser_result()
    try:
      result.success = self._handler.getConversationsByUser(args.request)
    except Exceptions.ttypes.UnavailableException, uEx:
      result.uEx = uEx
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    except DialogException, dEx:
      result.dEx = dEx
    oprot.writeMessageBegin("getConversationsByUser", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getUnreadReport(self, seqid, iprot, oprot):
    args = getUnreadReport_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getUnreadReport_result()
    try:
      result.success = self._handler.getUnreadReport(args.ownerId)
    except Exceptions.ttypes.UnavailableException, uEx:
      result.uEx = uEx
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    oprot.writeMessageBegin("getUnreadReport", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getUserDeals(self, seqid, iprot, oprot):
    args = getUserDeals_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getUserDeals_result()
    try:
      result.success = self._handler.getUserDeals(args.request)
    except Exceptions.ttypes.UnavailableException, uEx:
      result.uEx = uEx
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    except DialogException, dEx:
      result.dEx = dEx
    oprot.writeMessageBegin("getUserDeals", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getDealsWithUser(self, seqid, iprot, oprot):
    args = getDealsWithUser_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getDealsWithUser_result()
    try:
      result.success = self._handler.getDealsWithUser(args.request)
    except Exceptions.ttypes.UnavailableException, uEx:
      result.uEx = uEx
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    except DialogException, dEx:
      result.dEx = dEx
    oprot.writeMessageBegin("getDealsWithUser", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sendDealMessage(self, seqid, iprot, oprot):
    args = sendDealMessage_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sendDealMessage_result()
    try:
      result.success = self._handler.sendDealMessage(args.message, args.opponentId, args.wareId)
    except Exceptions.ttypes.UnavailableException, uEx:
      result.uEx = uEx
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    except SendMessageException, sEx:
      result.sEx = sEx
    oprot.writeMessageBegin("sendDealMessage", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_moveDealToArchive(self, seqid, iprot, oprot):
    args = moveDealToArchive_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = moveDealToArchive_result()
    try:
      result.success = self._handler.moveDealToArchive(args.dialogId, args.ownerId)
    except Exceptions.ttypes.UnavailableException, uEx:
      result.uEx = uEx
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    except DialogException, dEx:
      result.dEx = dEx
    oprot.writeMessageBegin("moveDealToArchive", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getAllWaresDeal(self, seqid, iprot, oprot):
    args = getAllWaresDeal_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getAllWaresDeal_result()
    try:
      result.success = self._handler.getAllWaresDeal(args.userDealsByWareRequest)
    except Exceptions.ttypes.UnavailableException, uEx:
      result.uEx = uEx
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    except DialogException, dEx:
      result.dEx = dEx
    oprot.writeMessageBegin("getAllWaresDeal", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getUserChats(self, seqid, iprot, oprot):
    args = getUserChats_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getUserChats_result()
    try:
      result.success = self._handler.getUserChats(args.filter)
    except Exceptions.ttypes.UnavailableException, uEx:
      result.uEx = uEx
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    oprot.writeMessageBegin("getUserChats", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findAllOpponents(self, seqid, iprot, oprot):
    args = findAllOpponents_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findAllOpponents_result()
    result.success = self._handler.findAllOpponents(args.userId)
    oprot.writeMessageBegin("findAllOpponents", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getBuyerDeals(self, seqid, iprot, oprot):
    args = getBuyerDeals_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getBuyerDeals_result()
    try:
      result.success = self._handler.getBuyerDeals(args.buyerId)
    except Exceptions.ttypes.UnavailableException, uEx:
      result.uEx = uEx
    oprot.writeMessageBegin("getBuyerDeals", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class markMessagesAsRead_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (MarkMessagesAsReadRequestDto, MarkMessagesAsReadRequestDto.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = MarkMessagesAsReadRequestDto()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('markMessagesAsRead_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class markMessagesAsRead_result:
  """
  Attributes:
   - uEx
   - bEx
   - nEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'uEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'nEx', (Exceptions.ttypes.NoSuchResourceException, Exceptions.ttypes.NoSuchResourceException.thrift_spec), None, ), # 3
  )

  def __init__(self, uEx=None, bEx=None, nEx=None,):
    self.uEx = uEx
    self.bEx = bEx
    self.nEx = nEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.uEx = Exceptions.ttypes.UnavailableException()
          self.uEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.nEx = Exceptions.ttypes.NoSuchResourceException()
          self.nEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('markMessagesAsRead_result')
    if self.uEx is not None:
      oprot.writeFieldBegin('uEx', TType.STRUCT, 1)
      self.uEx.write(oprot)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 2)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    if self.nEx is not None:
      oprot.writeFieldBegin('nEx', TType.STRUCT, 3)
      self.nEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class markDialogAsRead_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (MarkDialogAsReadRequestDto, MarkDialogAsReadRequestDto.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = MarkDialogAsReadRequestDto()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('markDialogAsRead_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class markDialogAsRead_result:
  """
  Attributes:
   - uEx
   - bEx
   - nEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'uEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'nEx', (Exceptions.ttypes.NoSuchResourceException, Exceptions.ttypes.NoSuchResourceException.thrift_spec), None, ), # 3
  )

  def __init__(self, uEx=None, bEx=None, nEx=None,):
    self.uEx = uEx
    self.bEx = bEx
    self.nEx = nEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.uEx = Exceptions.ttypes.UnavailableException()
          self.uEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.nEx = Exceptions.ttypes.NoSuchResourceException()
          self.nEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('markDialogAsRead_result')
    if self.uEx is not None:
      oprot.writeFieldBegin('uEx', TType.STRUCT, 1)
      self.uEx.write(oprot)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 2)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    if self.nEx is not None:
      oprot.writeFieldBegin('nEx', TType.STRUCT, 3)
      self.nEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getMessageHistory_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (MessageHistoryRequestDto, MessageHistoryRequestDto.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = MessageHistoryRequestDto()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getMessageHistory_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getMessageHistory_result:
  """
  Attributes:
   - success
   - uEx
   - bEx
   - nEx
   - mEx
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(InstantMessageDto, InstantMessageDto.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'uEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'nEx', (Exceptions.ttypes.NoSuchResourceException, Exceptions.ttypes.NoSuchResourceException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'mEx', (Exceptions.ttypes.MalformedException, Exceptions.ttypes.MalformedException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, uEx=None, bEx=None, nEx=None, mEx=None,):
    self.success = success
    self.uEx = uEx
    self.bEx = bEx
    self.nEx = nEx
    self.mEx = mEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype59, _size56) = iprot.readListBegin()
          for _i60 in xrange(_size56):
            _elem61 = InstantMessageDto()
            _elem61.read(iprot)
            self.success.append(_elem61)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.uEx = Exceptions.ttypes.UnavailableException()
          self.uEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.nEx = Exceptions.ttypes.NoSuchResourceException()
          self.nEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.mEx = Exceptions.ttypes.MalformedException()
          self.mEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getMessageHistory_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter62 in self.success:
        iter62.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.uEx is not None:
      oprot.writeFieldBegin('uEx', TType.STRUCT, 1)
      self.uEx.write(oprot)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 2)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    if self.nEx is not None:
      oprot.writeFieldBegin('nEx', TType.STRUCT, 3)
      self.nEx.write(oprot)
      oprot.writeFieldEnd()
    if self.mEx is not None:
      oprot.writeFieldBegin('mEx', TType.STRUCT, 4)
      self.mEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getChatWithUser_args:
  """
  Attributes:
   - ownerId
   - opponentId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'ownerId', None, None, ), # 1
    (2, TType.I32, 'opponentId', None, None, ), # 2
  )

  def __init__(self, ownerId=None, opponentId=None,):
    self.ownerId = ownerId
    self.opponentId = opponentId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.ownerId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.opponentId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getChatWithUser_args')
    if self.ownerId is not None:
      oprot.writeFieldBegin('ownerId', TType.I32, 1)
      oprot.writeI32(self.ownerId)
      oprot.writeFieldEnd()
    if self.opponentId is not None:
      oprot.writeFieldBegin('opponentId', TType.I32, 2)
      oprot.writeI32(self.opponentId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getChatWithUser_result:
  """
  Attributes:
   - success
   - uEx
   - bEx
   - nEx
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (DialogInfoDto, DialogInfoDto.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'uEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'nEx', (Exceptions.ttypes.NullResultException, Exceptions.ttypes.NullResultException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, uEx=None, bEx=None, nEx=None,):
    self.success = success
    self.uEx = uEx
    self.bEx = bEx
    self.nEx = nEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = DialogInfoDto()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.uEx = Exceptions.ttypes.UnavailableException()
          self.uEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.nEx = Exceptions.ttypes.NullResultException()
          self.nEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getChatWithUser_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.uEx is not None:
      oprot.writeFieldBegin('uEx', TType.STRUCT, 1)
      self.uEx.write(oprot)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 2)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    if self.nEx is not None:
      oprot.writeFieldBegin('nEx', TType.STRUCT, 3)
      self.nEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDealById_args:
  """
  Attributes:
   - dealId
   - ownerId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dealId', None, None, ), # 1
    (2, TType.I32, 'ownerId', None, None, ), # 2
  )

  def __init__(self, dealId=None, ownerId=None,):
    self.dealId = dealId
    self.ownerId = ownerId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dealId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ownerId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDealById_args')
    if self.dealId is not None:
      oprot.writeFieldBegin('dealId', TType.STRING, 1)
      oprot.writeString(self.dealId)
      oprot.writeFieldEnd()
    if self.ownerId is not None:
      oprot.writeFieldBegin('ownerId', TType.I32, 2)
      oprot.writeI32(self.ownerId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDealById_result:
  """
  Attributes:
   - success
   - uEx
   - bEx
   - nEx
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (DealInfoDto, DealInfoDto.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'uEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'nEx', (Exceptions.ttypes.NullResultException, Exceptions.ttypes.NullResultException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, uEx=None, bEx=None, nEx=None,):
    self.success = success
    self.uEx = uEx
    self.bEx = bEx
    self.nEx = nEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = DealInfoDto()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.uEx = Exceptions.ttypes.UnavailableException()
          self.uEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.nEx = Exceptions.ttypes.NullResultException()
          self.nEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDealById_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.uEx is not None:
      oprot.writeFieldBegin('uEx', TType.STRUCT, 1)
      self.uEx.write(oprot)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 2)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    if self.nEx is not None:
      oprot.writeFieldBegin('nEx', TType.STRUCT, 3)
      self.nEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sendChatMessageToUser_args:
  """
  Attributes:
   - message
   - opponentId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'message', (BaseInstantMessageDto, BaseInstantMessageDto.thrift_spec), None, ), # 1
    (2, TType.I32, 'opponentId', None, None, ), # 2
  )

  def __init__(self, message=None, opponentId=None,):
    self.message = message
    self.opponentId = opponentId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.message = BaseInstantMessageDto()
          self.message.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.opponentId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sendChatMessageToUser_args')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRUCT, 1)
      self.message.write(oprot)
      oprot.writeFieldEnd()
    if self.opponentId is not None:
      oprot.writeFieldBegin('opponentId', TType.I32, 2)
      oprot.writeI32(self.opponentId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sendChatMessageToUser_result:
  """
  Attributes:
   - success
   - uEx
   - bEx
   - sEx
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (InstantMessageDto, InstantMessageDto.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'uEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'sEx', (SendMessageException, SendMessageException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, uEx=None, bEx=None, sEx=None,):
    self.success = success
    self.uEx = uEx
    self.bEx = bEx
    self.sEx = sEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = InstantMessageDto()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.uEx = Exceptions.ttypes.UnavailableException()
          self.uEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.sEx = SendMessageException()
          self.sEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sendChatMessageToUser_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.uEx is not None:
      oprot.writeFieldBegin('uEx', TType.STRUCT, 1)
      self.uEx.write(oprot)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 2)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    if self.sEx is not None:
      oprot.writeFieldBegin('sEx', TType.STRUCT, 3)
      self.sEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getConversationsByUser_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (ConversationsRequest, ConversationsRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = ConversationsRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getConversationsByUser_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getConversationsByUser_result:
  """
  Attributes:
   - success
   - uEx
   - bEx
   - dEx
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(UserConversationInfo, UserConversationInfo.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'uEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'dEx', (DialogException, DialogException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, uEx=None, bEx=None, dEx=None,):
    self.success = success
    self.uEx = uEx
    self.bEx = bEx
    self.dEx = dEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype66, _size63) = iprot.readListBegin()
          for _i67 in xrange(_size63):
            _elem68 = UserConversationInfo()
            _elem68.read(iprot)
            self.success.append(_elem68)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.uEx = Exceptions.ttypes.UnavailableException()
          self.uEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.dEx = DialogException()
          self.dEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getConversationsByUser_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter69 in self.success:
        iter69.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.uEx is not None:
      oprot.writeFieldBegin('uEx', TType.STRUCT, 1)
      self.uEx.write(oprot)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 2)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    if self.dEx is not None:
      oprot.writeFieldBegin('dEx', TType.STRUCT, 3)
      self.dEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUnreadReport_args:
  """
  Attributes:
   - ownerId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'ownerId', None, None, ), # 1
  )

  def __init__(self, ownerId=None,):
    self.ownerId = ownerId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.ownerId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUnreadReport_args')
    if self.ownerId is not None:
      oprot.writeFieldBegin('ownerId', TType.I32, 1)
      oprot.writeI32(self.ownerId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUnreadReport_result:
  """
  Attributes:
   - success
   - uEx
   - bEx
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (UnreadReportDto, UnreadReportDto.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'uEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, uEx=None, bEx=None,):
    self.success = success
    self.uEx = uEx
    self.bEx = bEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = UnreadReportDto()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.uEx = Exceptions.ttypes.UnavailableException()
          self.uEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUnreadReport_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.uEx is not None:
      oprot.writeFieldBegin('uEx', TType.STRUCT, 1)
      self.uEx.write(oprot)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 2)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUserDeals_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (UserDealsRequestDto, UserDealsRequestDto.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = UserDealsRequestDto()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUserDeals_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUserDeals_result:
  """
  Attributes:
   - success
   - uEx
   - bEx
   - dEx
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (UserDealsDto, UserDealsDto.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'uEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'dEx', (DialogException, DialogException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, uEx=None, bEx=None, dEx=None,):
    self.success = success
    self.uEx = uEx
    self.bEx = bEx
    self.dEx = dEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = UserDealsDto()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.uEx = Exceptions.ttypes.UnavailableException()
          self.uEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.dEx = DialogException()
          self.dEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUserDeals_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.uEx is not None:
      oprot.writeFieldBegin('uEx', TType.STRUCT, 1)
      self.uEx.write(oprot)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 2)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    if self.dEx is not None:
      oprot.writeFieldBegin('dEx', TType.STRUCT, 3)
      self.dEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDealsWithUser_args:
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (DealsWithUserRequest, DealsWithUserRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = DealsWithUserRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDealsWithUser_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDealsWithUser_result:
  """
  Attributes:
   - success
   - uEx
   - bEx
   - dEx
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(DealInfoDto, DealInfoDto.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'uEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'dEx', (DialogException, DialogException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, uEx=None, bEx=None, dEx=None,):
    self.success = success
    self.uEx = uEx
    self.bEx = bEx
    self.dEx = dEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype73, _size70) = iprot.readListBegin()
          for _i74 in xrange(_size70):
            _elem75 = DealInfoDto()
            _elem75.read(iprot)
            self.success.append(_elem75)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.uEx = Exceptions.ttypes.UnavailableException()
          self.uEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.dEx = DialogException()
          self.dEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDealsWithUser_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter76 in self.success:
        iter76.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.uEx is not None:
      oprot.writeFieldBegin('uEx', TType.STRUCT, 1)
      self.uEx.write(oprot)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 2)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    if self.dEx is not None:
      oprot.writeFieldBegin('dEx', TType.STRUCT, 3)
      self.dEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sendDealMessage_args:
  """
  Attributes:
   - message
   - opponentId
   - wareId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'message', (BaseInstantMessageDto, BaseInstantMessageDto.thrift_spec), None, ), # 1
    (2, TType.I32, 'opponentId', None, None, ), # 2
    (3, TType.STRING, 'wareId', None, None, ), # 3
  )

  def __init__(self, message=None, opponentId=None, wareId=None,):
    self.message = message
    self.opponentId = opponentId
    self.wareId = wareId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.message = BaseInstantMessageDto()
          self.message.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.opponentId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.wareId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sendDealMessage_args')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRUCT, 1)
      self.message.write(oprot)
      oprot.writeFieldEnd()
    if self.opponentId is not None:
      oprot.writeFieldBegin('opponentId', TType.I32, 2)
      oprot.writeI32(self.opponentId)
      oprot.writeFieldEnd()
    if self.wareId is not None:
      oprot.writeFieldBegin('wareId', TType.STRING, 3)
      oprot.writeString(self.wareId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sendDealMessage_result:
  """
  Attributes:
   - success
   - uEx
   - bEx
   - sEx
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (InstantMessageDto, InstantMessageDto.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'uEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'sEx', (SendMessageException, SendMessageException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, uEx=None, bEx=None, sEx=None,):
    self.success = success
    self.uEx = uEx
    self.bEx = bEx
    self.sEx = sEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = InstantMessageDto()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.uEx = Exceptions.ttypes.UnavailableException()
          self.uEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.sEx = SendMessageException()
          self.sEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sendDealMessage_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.uEx is not None:
      oprot.writeFieldBegin('uEx', TType.STRUCT, 1)
      self.uEx.write(oprot)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 2)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    if self.sEx is not None:
      oprot.writeFieldBegin('sEx', TType.STRUCT, 3)
      self.sEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class moveDealToArchive_args:
  """
  Attributes:
   - dialogId
   - ownerId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dialogId', None, None, ), # 1
    (2, TType.I32, 'ownerId', None, None, ), # 2
  )

  def __init__(self, dialogId=None, ownerId=None,):
    self.dialogId = dialogId
    self.ownerId = ownerId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dialogId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ownerId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('moveDealToArchive_args')
    if self.dialogId is not None:
      oprot.writeFieldBegin('dialogId', TType.STRING, 1)
      oprot.writeString(self.dialogId)
      oprot.writeFieldEnd()
    if self.ownerId is not None:
      oprot.writeFieldBegin('ownerId', TType.I32, 2)
      oprot.writeI32(self.ownerId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class moveDealToArchive_result:
  """
  Attributes:
   - success
   - uEx
   - bEx
   - dEx
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (DealInfoDto, DealInfoDto.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'uEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'dEx', (DialogException, DialogException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, uEx=None, bEx=None, dEx=None,):
    self.success = success
    self.uEx = uEx
    self.bEx = bEx
    self.dEx = dEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = DealInfoDto()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.uEx = Exceptions.ttypes.UnavailableException()
          self.uEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.dEx = DialogException()
          self.dEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('moveDealToArchive_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.uEx is not None:
      oprot.writeFieldBegin('uEx', TType.STRUCT, 1)
      self.uEx.write(oprot)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 2)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    if self.dEx is not None:
      oprot.writeFieldBegin('dEx', TType.STRUCT, 3)
      self.dEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAllWaresDeal_args:
  """
  Attributes:
   - userDealsByWareRequest
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'userDealsByWareRequest', (FilterByUserRequest, FilterByUserRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, userDealsByWareRequest=None,):
    self.userDealsByWareRequest = userDealsByWareRequest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.userDealsByWareRequest = FilterByUserRequest()
          self.userDealsByWareRequest.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAllWaresDeal_args')
    if self.userDealsByWareRequest is not None:
      oprot.writeFieldBegin('userDealsByWareRequest', TType.STRUCT, 1)
      self.userDealsByWareRequest.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAllWaresDeal_result:
  """
  Attributes:
   - success
   - uEx
   - bEx
   - dEx
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (MessagesReport, MessagesReport.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'uEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'dEx', (DialogException, DialogException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, uEx=None, bEx=None, dEx=None,):
    self.success = success
    self.uEx = uEx
    self.bEx = bEx
    self.dEx = dEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = MessagesReport()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.uEx = Exceptions.ttypes.UnavailableException()
          self.uEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.dEx = DialogException()
          self.dEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAllWaresDeal_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.uEx is not None:
      oprot.writeFieldBegin('uEx', TType.STRUCT, 1)
      self.uEx.write(oprot)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 2)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    if self.dEx is not None:
      oprot.writeFieldBegin('dEx', TType.STRUCT, 3)
      self.dEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUserChats_args:
  """
  Attributes:
   - filter
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'filter', (FilterByUserRequest, FilterByUserRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, filter=None,):
    self.filter = filter

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.filter = FilterByUserRequest()
          self.filter.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUserChats_args')
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRUCT, 1)
      self.filter.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUserChats_result:
  """
  Attributes:
   - success
   - uEx
   - bEx
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (UserDialogsDto, UserDialogsDto.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'uEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, uEx=None, bEx=None,):
    self.success = success
    self.uEx = uEx
    self.bEx = bEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = UserDialogsDto()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.uEx = Exceptions.ttypes.UnavailableException()
          self.uEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUserChats_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.uEx is not None:
      oprot.writeFieldBegin('uEx', TType.STRUCT, 1)
      self.uEx.write(oprot)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 2)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findAllOpponents_args:
  """
  Attributes:
   - userId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'userId', None, None, ), # 1
  )

  def __init__(self, userId=None,):
    self.userId = userId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.userId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findAllOpponents_args')
    if self.userId is not None:
      oprot.writeFieldBegin('userId', TType.I32, 1)
      oprot.writeI32(self.userId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findAllOpponents_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype80, _size77) = iprot.readListBegin()
          for _i81 in xrange(_size77):
            _elem82 = iprot.readI32();
            self.success.append(_elem82)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findAllOpponents_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter83 in self.success:
        oprot.writeI32(iter83)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getBuyerDeals_args:
  """
  Attributes:
   - buyerId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'buyerId', None, None, ), # 1
  )

  def __init__(self, buyerId=None,):
    self.buyerId = buyerId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.buyerId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getBuyerDeals_args')
    if self.buyerId is not None:
      oprot.writeFieldBegin('buyerId', TType.I32, 1)
      oprot.writeI32(self.buyerId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getBuyerDeals_result:
  """
  Attributes:
   - success
   - uEx
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (UserDealsDto, UserDealsDto.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'uEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, uEx=None,):
    self.success = success
    self.uEx = uEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = UserDealsDto()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.uEx = Exceptions.ttypes.UnavailableException()
          self.uEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getBuyerDeals_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.uEx is not None:
      oprot.writeFieldBegin('uEx', TType.STRUCT, 1)
      self.uEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
