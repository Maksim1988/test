# -*- coding: utf-8 -*-
#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from gen_py import InstantMessagesContent
import gen_py.Exceptions.ttypes
import gen_py.Common.ttypes
import gen_py.InstantMessagesContent.ttypes
import gen_py.InstantMessagingWorkerConstants.ttypes
import gen_py.DealsWorker.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None



class PaginationMarkerDto:
  """
  Attributes:
   - from
   - to
  """

  thrift_spec = (
    None, # 0
    None, # 1
    None, # 2
    None, # 3
    None, # 4
    (5, TType.DOUBLE, 'from', None, None, ), # 5
    (6, TType.DOUBLE, 'to', None, None, ), # 6
  )

  def __init__(self, tfrom=None, to=None,):
    self.tfrom = tfrom
    self.to = to

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 5:
        if ftype == TType.DOUBLE:
          self.tfrom = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.DOUBLE:
          self.to = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PaginationMarkerDto')
    if self.tfrom is not None:
      oprot.writeFieldBegin('from', TType.DOUBLE, 5)
      oprot.writeDouble(self.tfrom)
      oprot.writeFieldEnd()
    if self.to is not None:
      oprot.writeFieldBegin('to', TType.DOUBLE, 6)
      oprot.writeDouble(self.to)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DialogInfoDto:
  """
   * Информация о диалоге/сделке возвращаемая сервером.
  *

  Attributes:
   - dialogId
   - ownerId:  * Владелец диалога (каждый пользователь владеет своей копией диалога!)
  *
   - opponentId:  * Собеседник
  *
   - startTimestamp:  * Время создания диалога
  *
   - lastUpdateTimestamp:  * Время последнего сообщения в диалоге
  *
   - unreadMessagesCount:  * Количество непрочитанных сообщений пользователем
  *
   - marker
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dialogId', None, None, ), # 1
    (2, TType.I32, 'ownerId', None, None, ), # 2
    (3, TType.I32, 'opponentId', None, None, ), # 3
    (4, TType.I64, 'startTimestamp', None, None, ), # 4
    (5, TType.I64, 'lastUpdateTimestamp', None, None, ), # 5
    (6, TType.I32, 'unreadMessagesCount', None, None, ), # 6
    (7, TType.STRUCT, 'marker', (PaginationMarkerDto, PaginationMarkerDto.thrift_spec), None, ), # 7
  )

  def __init__(self, dialogId=None, ownerId=None, opponentId=None, startTimestamp=None, lastUpdateTimestamp=None, unreadMessagesCount=None, marker=None,):
    self.dialogId = dialogId
    self.ownerId = ownerId
    self.opponentId = opponentId
    self.startTimestamp = startTimestamp
    self.lastUpdateTimestamp = lastUpdateTimestamp
    self.unreadMessagesCount = unreadMessagesCount
    self.marker = marker

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dialogId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ownerId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.opponentId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.startTimestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.lastUpdateTimestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.unreadMessagesCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.marker = PaginationMarkerDto()
          self.marker.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DialogInfoDto')
    if self.dialogId is not None:
      oprot.writeFieldBegin('dialogId', TType.STRING, 1)
      oprot.writeString(self.dialogId)
      oprot.writeFieldEnd()
    if self.ownerId is not None:
      oprot.writeFieldBegin('ownerId', TType.I32, 2)
      oprot.writeI32(self.ownerId)
      oprot.writeFieldEnd()
    if self.opponentId is not None:
      oprot.writeFieldBegin('opponentId', TType.I32, 3)
      oprot.writeI32(self.opponentId)
      oprot.writeFieldEnd()
    if self.startTimestamp is not None:
      oprot.writeFieldBegin('startTimestamp', TType.I64, 4)
      oprot.writeI64(self.startTimestamp)
      oprot.writeFieldEnd()
    if self.lastUpdateTimestamp is not None:
      oprot.writeFieldBegin('lastUpdateTimestamp', TType.I64, 5)
      oprot.writeI64(self.lastUpdateTimestamp)
      oprot.writeFieldEnd()
    if self.unreadMessagesCount is not None:
      oprot.writeFieldBegin('unreadMessagesCount', TType.I32, 6)
      oprot.writeI32(self.unreadMessagesCount)
      oprot.writeFieldEnd()
    if self.marker is not None:
      oprot.writeFieldBegin('marker', TType.STRUCT, 7)
      self.marker.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DealInfoDto:
  """
   * Информация по сделкеб включает в себя информацию по диалогу и идентификатор товара
  *

  Attributes:
   - dialog:  * Диалог сделки
  *
   - dealStatus:  * Текущий/актуальный статус сделки
  *
   - wareId:  * Идентификатор товара по которому заключается сделка
  *
   - activityState:  * Состояние сделки
  *
   - archivationTimestamp:  * Время переноса сделки в архив пользователем
  *
   - lastDealAction:  * Информация о последнем сделочном сообщении
  *
   - lastDealActionBy:  * Кем было послано последнее сделочное сообщение
  *
   - marker
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRUCT, 'dialog', (DialogInfoDto, DialogInfoDto.thrift_spec), None, ), # 2
    (3, TType.I32, 'dealStatus', None, None, ), # 3
    (4, TType.STRING, 'wareId', None, None, ), # 4
    (5, TType.I32, 'activityState', None, None, ), # 5
    (6, TType.I64, 'archivationTimestamp', None, None, ), # 6
    (7, TType.STRUCT, 'lastDealAction', (InstantMessagesContent.ttypes.DealContentDto, InstantMessagesContent.ttypes.DealContentDto.thrift_spec), None, ), # 7
    (8, TType.I32, 'lastDealActionBy', None, None, ), # 8
    (9, TType.STRUCT, 'marker', (PaginationMarkerDto, PaginationMarkerDto.thrift_spec), None, ), # 9
  )

  def __init__(self, dialog=None, dealStatus=None, wareId=None, activityState=None, archivationTimestamp=None, lastDealAction=None, lastDealActionBy=None, marker=None,):
    self.dialog = dialog
    self.dealStatus = dealStatus
    self.wareId = wareId
    self.activityState = activityState
    self.archivationTimestamp = archivationTimestamp
    self.lastDealAction = lastDealAction
    self.lastDealActionBy = lastDealActionBy
    self.marker = marker

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRUCT:
          self.dialog = DialogInfoDto()
          self.dialog.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.dealStatus = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.wareId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.activityState = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.archivationTimestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.lastDealAction = InstantMessagesContent.ttypes.DealContentDto()
          self.lastDealAction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.lastDealActionBy = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.marker = PaginationMarkerDto()
          self.marker.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DealInfoDto')
    if self.dialog is not None:
      oprot.writeFieldBegin('dialog', TType.STRUCT, 2)
      self.dialog.write(oprot)
      oprot.writeFieldEnd()
    if self.dealStatus is not None:
      oprot.writeFieldBegin('dealStatus', TType.I32, 3)
      oprot.writeI32(self.dealStatus)
      oprot.writeFieldEnd()
    if self.wareId is not None:
      oprot.writeFieldBegin('wareId', TType.STRING, 4)
      oprot.writeString(self.wareId)
      oprot.writeFieldEnd()
    if self.activityState is not None:
      oprot.writeFieldBegin('activityState', TType.I32, 5)
      oprot.writeI32(self.activityState)
      oprot.writeFieldEnd()
    if self.archivationTimestamp is not None:
      oprot.writeFieldBegin('archivationTimestamp', TType.I64, 6)
      oprot.writeI64(self.archivationTimestamp)
      oprot.writeFieldEnd()
    if self.lastDealAction is not None:
      oprot.writeFieldBegin('lastDealAction', TType.STRUCT, 7)
      self.lastDealAction.write(oprot)
      oprot.writeFieldEnd()
    if self.lastDealActionBy is not None:
      oprot.writeFieldBegin('lastDealActionBy', TType.I32, 8)
      oprot.writeI32(self.lastDealActionBy)
      oprot.writeFieldEnd()
    if self.marker is not None:
      oprot.writeFieldBegin('marker', TType.STRUCT, 9)
      self.marker.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BaseInstantMessageDto:
  """
   * Базовая информация о сообщении
  *

  Attributes:
   - ownerId:  * Отправитель сообщения
  *
   - items:  * Содержимое сообщения
  *
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'ownerId', None, None, ), # 1
    (2, TType.LIST, 'items', (TType.STRUCT,(InstantMessagesContent.ttypes.ContentItemDto, InstantMessagesContent.ttypes.ContentItemDto.thrift_spec)), None, ), # 2
  )

  def __init__(self, ownerId=None, items=None,):
    self.ownerId = ownerId
    self.items = items

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.ownerId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.items = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = InstantMessagesContent.ttypes.ContentItemDto()
            _elem5.read(iprot)
            self.items.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BaseInstantMessageDto')
    if self.ownerId is not None:
      oprot.writeFieldBegin('ownerId', TType.I32, 1)
      oprot.writeI32(self.ownerId)
      oprot.writeFieldEnd()
    if self.items is not None:
      oprot.writeFieldBegin('items', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.items))
      for iter6 in self.items:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InstantMessageDto:
  """
   * Сообщение может быть разных типов, в зависимости от содержащегося в нем контента. В одном сообщении может содержаться
   * несколько "пунктов" (items) разных типов. Например в сообщении может быть 3 под пункта: текст, картинка, предложение цены
  *

  Attributes:
   - messageId:  * Message id
  *
   - message:  * Содержимое сообщения
  *
   - dialogId:  * Идентификатор диалога
  *
   - creationTimestamp:  * Вермя создания (отправки) сообщения на клиенте
  *
   - readTimestamp
   - paginationMarker
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'messageId', None, None, ), # 1
    (2, TType.STRUCT, 'message', (BaseInstantMessageDto, BaseInstantMessageDto.thrift_spec), None, ), # 2
    (3, TType.STRING, 'dialogId', None, None, ), # 3
    (4, TType.I64, 'creationTimestamp', None, None, ), # 4
    (5, TType.I64, 'readTimestamp', None, None, ), # 5
    (6, TType.STRUCT, 'paginationMarker', (PaginationMarkerDto, PaginationMarkerDto.thrift_spec), None, ), # 6
  )

  def __init__(self, messageId=None, message=None, dialogId=None, creationTimestamp=None, readTimestamp=None, paginationMarker=None,):
    self.messageId = messageId
    self.message = message
    self.dialogId = dialogId
    self.creationTimestamp = creationTimestamp
    self.readTimestamp = readTimestamp
    self.paginationMarker = paginationMarker

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.messageId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.message = BaseInstantMessageDto()
          self.message.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.dialogId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.creationTimestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.readTimestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.paginationMarker = PaginationMarkerDto()
          self.paginationMarker.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InstantMessageDto')
    if self.messageId is not None:
      oprot.writeFieldBegin('messageId', TType.STRING, 1)
      oprot.writeString(self.messageId)
      oprot.writeFieldEnd()
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRUCT, 2)
      self.message.write(oprot)
      oprot.writeFieldEnd()
    if self.dialogId is not None:
      oprot.writeFieldBegin('dialogId', TType.STRING, 3)
      oprot.writeString(self.dialogId)
      oprot.writeFieldEnd()
    if self.creationTimestamp is not None:
      oprot.writeFieldBegin('creationTimestamp', TType.I64, 4)
      oprot.writeI64(self.creationTimestamp)
      oprot.writeFieldEnd()
    if self.readTimestamp is not None:
      oprot.writeFieldBegin('readTimestamp', TType.I64, 5)
      oprot.writeI64(self.readTimestamp)
      oprot.writeFieldEnd()
    if self.paginationMarker is not None:
      oprot.writeFieldBegin('paginationMarker', TType.STRUCT, 6)
      self.paginationMarker.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MarkMessagesAsReadRequestDto:
  """
  Attributes:
   - ownerId
   - messages
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'ownerId', None, None, ), # 1
    (2, TType.LIST, 'messages', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, ownerId=None, messages=None,):
    self.ownerId = ownerId
    self.messages = messages

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.ownerId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.messages = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readString();
            self.messages.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MarkMessagesAsReadRequestDto')
    if self.ownerId is not None:
      oprot.writeFieldBegin('ownerId', TType.I32, 1)
      oprot.writeI32(self.ownerId)
      oprot.writeFieldEnd()
    if self.messages is not None:
      oprot.writeFieldBegin('messages', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.messages))
      for iter13 in self.messages:
        oprot.writeString(iter13)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MarkDialogAsReadRequestDto:
  """
  Attributes:
   - ownerId
   - dialogId
   - lastReadTimestamp
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'ownerId', None, None, ), # 1
    (2, TType.STRING, 'dialogId', None, None, ), # 2
    (3, TType.I64, 'lastReadTimestamp', None, None, ), # 3
  )

  def __init__(self, ownerId=None, dialogId=None, lastReadTimestamp=None,):
    self.ownerId = ownerId
    self.dialogId = dialogId
    self.lastReadTimestamp = lastReadTimestamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.ownerId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dialogId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.lastReadTimestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MarkDialogAsReadRequestDto')
    if self.ownerId is not None:
      oprot.writeFieldBegin('ownerId', TType.I32, 1)
      oprot.writeI32(self.ownerId)
      oprot.writeFieldEnd()
    if self.dialogId is not None:
      oprot.writeFieldBegin('dialogId', TType.STRING, 2)
      oprot.writeString(self.dialogId)
      oprot.writeFieldEnd()
    if self.lastReadTimestamp is not None:
      oprot.writeFieldBegin('lastReadTimestamp', TType.I64, 3)
      oprot.writeI64(self.lastReadTimestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MessageHistoryRequestDto:
  """
   * Запрос получения истории сообщений
  *

  Attributes:
   - ownerId:  * Owner id
  *
   - dialogId:  * Идентификатор диалога
  *
   - limit:  * Максимальное количество сообщений
  *
   - offset:  * Смещение
  *
   - paginationMarker
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'ownerId', None, None, ), # 1
    (2, TType.STRING, 'dialogId', None, None, ), # 2
    (3, TType.I32, 'limit', None, None, ), # 3
    (4, TType.I32, 'offset', None, None, ), # 4
    (5, TType.STRUCT, 'paginationMarker', (PaginationMarkerDto, PaginationMarkerDto.thrift_spec), None, ), # 5
  )

  def __init__(self, ownerId=None, dialogId=None, limit=None, offset=None, paginationMarker=None,):
    self.ownerId = ownerId
    self.dialogId = dialogId
    self.limit = limit
    self.offset = offset
    self.paginationMarker = paginationMarker

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.ownerId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dialogId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.limit = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.offset = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.paginationMarker = PaginationMarkerDto()
          self.paginationMarker.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MessageHistoryRequestDto')
    if self.ownerId is not None:
      oprot.writeFieldBegin('ownerId', TType.I32, 1)
      oprot.writeI32(self.ownerId)
      oprot.writeFieldEnd()
    if self.dialogId is not None:
      oprot.writeFieldBegin('dialogId', TType.STRING, 2)
      oprot.writeString(self.dialogId)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 3)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I32, 4)
      oprot.writeI32(self.offset)
      oprot.writeFieldEnd()
    if self.paginationMarker is not None:
      oprot.writeFieldBegin('paginationMarker', TType.STRUCT, 5)
      self.paginationMarker.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DialogsRequestDto:
  """
  Запрос получения списка диалогов пользователя


  Attributes:
   - userId
   - limit:  * максимальное количество диалогов
  *
   - offsetTimestamp:  * Все диалоги в которых время последнего сообщения превышает offsetTimeStamp
  *
   - unreadOnly:  * Возвращать только непрочитанные сообщения
  *
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'userId', None, None, ), # 1
    (2, TType.I32, 'limit', None, None, ), # 2
    (3, TType.I64, 'offsetTimestamp', None, None, ), # 3
    (4, TType.BOOL, 'unreadOnly', None, False, ), # 4
  )

  def __init__(self, userId=None, limit=None, offsetTimestamp=None, unreadOnly=thrift_spec[4][4],):
    self.userId = userId
    self.limit = limit
    self.offsetTimestamp = offsetTimestamp
    self.unreadOnly = unreadOnly

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.userId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.limit = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.offsetTimestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.unreadOnly = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DialogsRequestDto')
    if self.userId is not None:
      oprot.writeFieldBegin('userId', TType.I32, 1)
      oprot.writeI32(self.userId)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 2)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    if self.offsetTimestamp is not None:
      oprot.writeFieldBegin('offsetTimestamp', TType.I64, 3)
      oprot.writeI64(self.offsetTimestamp)
      oprot.writeFieldEnd()
    if self.unreadOnly is not None:
      oprot.writeFieldBegin('unreadOnly', TType.BOOL, 4)
      oprot.writeBool(self.unreadOnly)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StartDialogRequestDto:
  """
   * Запрос создания нового диалога
  *

  Attributes:
   - users:  * Ид участников диалога
  *
   - initMessage:  * Стартовое сообщение
  *
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'users', (TType.I32,None), None, ), # 1
    (2, TType.STRUCT, 'initMessage', (BaseInstantMessageDto, BaseInstantMessageDto.thrift_spec), None, ), # 2
  )

  def __init__(self, users=None, initMessage=None,):
    self.users = users
    self.initMessage = initMessage

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.users = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = iprot.readI32();
            self.users.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.initMessage = BaseInstantMessageDto()
          self.initMessage.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StartDialogRequestDto')
    if self.users is not None:
      oprot.writeFieldBegin('users', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.users))
      for iter20 in self.users:
        oprot.writeI32(iter20)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.initMessage is not None:
      oprot.writeFieldBegin('initMessage', TType.STRUCT, 2)
      self.initMessage.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DealsWithUserRequest:
  """
   * Запрос на получение списка сделок сгруппированных по данному оппоненту
  *

  Attributes:
   - ownerId:  * Обязательное поле
  *
   - opponentId:  * Обязательное поле
  *
   - wareId:  * Идентификатор товара (все сделки заключаются по товару)
  *
   - dealStatuses:  * Список статусов диалогов - диалогов имеющие находящиеся в этих статусах в данный момент
  *
   - limit
   - offset
   - activityState:  * Выбрать диалоги которые находятся в данном состоянии
  *
   - marker
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'ownerId', None, None, ), # 1
    (2, TType.I32, 'opponentId', None, None, ), # 2
    (3, TType.STRING, 'wareId', None, None, ), # 3
    (4, TType.LIST, 'dealStatuses', (TType.I32,None), None, ), # 4
    (5, TType.I32, 'limit', None, None, ), # 5
    (6, TType.I32, 'offset', None, None, ), # 6
    (7, TType.LIST, 'activityState', (TType.I32,None), None, ), # 7
    (8, TType.STRUCT, 'marker', (PaginationMarkerDto, PaginationMarkerDto.thrift_spec), None, ), # 8
  )

  def __init__(self, ownerId=None, opponentId=None, wareId=None, dealStatuses=None, limit=None, offset=None, activityState=None, marker=None,):
    self.ownerId = ownerId
    self.opponentId = opponentId
    self.wareId = wareId
    self.dealStatuses = dealStatuses
    self.limit = limit
    self.offset = offset
    self.activityState = activityState
    self.marker = marker

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.ownerId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.opponentId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.wareId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.dealStatuses = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = iprot.readI32();
            self.dealStatuses.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.limit = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.offset = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.activityState = []
          (_etype30, _size27) = iprot.readListBegin()
          for _i31 in xrange(_size27):
            _elem32 = iprot.readI32();
            self.activityState.append(_elem32)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.marker = PaginationMarkerDto()
          self.marker.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DealsWithUserRequest')
    if self.ownerId is not None:
      oprot.writeFieldBegin('ownerId', TType.I32, 1)
      oprot.writeI32(self.ownerId)
      oprot.writeFieldEnd()
    if self.opponentId is not None:
      oprot.writeFieldBegin('opponentId', TType.I32, 2)
      oprot.writeI32(self.opponentId)
      oprot.writeFieldEnd()
    if self.wareId is not None:
      oprot.writeFieldBegin('wareId', TType.STRING, 3)
      oprot.writeString(self.wareId)
      oprot.writeFieldEnd()
    if self.dealStatuses is not None:
      oprot.writeFieldBegin('dealStatuses', TType.LIST, 4)
      oprot.writeListBegin(TType.I32, len(self.dealStatuses))
      for iter33 in self.dealStatuses:
        oprot.writeI32(iter33)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 5)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I32, 6)
      oprot.writeI32(self.offset)
      oprot.writeFieldEnd()
    if self.activityState is not None:
      oprot.writeFieldBegin('activityState', TType.LIST, 7)
      oprot.writeListBegin(TType.I32, len(self.activityState))
      for iter34 in self.activityState:
        oprot.writeI32(iter34)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.marker is not None:
      oprot.writeFieldBegin('marker', TType.STRUCT, 8)
      self.marker.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ConversationsRequest:
  """
  Attributes:
   - ownerId
   - limit
   - offset
   - marker
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'ownerId', None, None, ), # 1
    (2, TType.I32, 'limit', None, None, ), # 2
    (3, TType.I32, 'offset', None, None, ), # 3
    (4, TType.STRUCT, 'marker', (PaginationMarkerDto, PaginationMarkerDto.thrift_spec), None, ), # 4
  )

  def __init__(self, ownerId=None, limit=None, offset=None, marker=None,):
    self.ownerId = ownerId
    self.limit = limit
    self.offset = offset
    self.marker = marker

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.ownerId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.limit = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.offset = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.marker = PaginationMarkerDto()
          self.marker.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ConversationsRequest')
    if self.ownerId is not None:
      oprot.writeFieldBegin('ownerId', TType.I32, 1)
      oprot.writeI32(self.ownerId)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 2)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I32, 3)
      oprot.writeI32(self.offset)
      oprot.writeFieldEnd()
    if self.marker is not None:
      oprot.writeFieldBegin('marker', TType.STRUCT, 4)
      self.marker.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UserConversationInfo:
  """
   * Информация по диалогам и сделкам с оппонентом
  *

  Attributes:
   - opponentId:  * Идентификатор оппонента для текущего юзера
  *
   - lastDialog:  * мета инфо о диалоге в котором находится последнее сообщение
  *
   - lastDeal:  * Информация о последней сделке с оппонентом
  *
   - lastMessage:  * Последнее сообщение в чате или сделке (прочитанное или не прочитанное)
  *
   - unreadChatMessagesCount:  * Количество непрочитанных сообщений в чатике с оппонентом (чатик с оппонентом может быть только один)
  *
   - unreadDealMessagesCount:  * Количество непрочитанных сообщений во всех сделках с оппонентом
  *
   - unreadChatsCount:  * Количество непрочитанных чатов
  *
   - unreadDealsCount:  * Количество непрочитанных сделок
  *
   - marker
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'opponentId', None, None, ), # 1
    (2, TType.STRUCT, 'lastDialog', (DialogInfoDto, DialogInfoDto.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'lastDeal', (DealInfoDto, DealInfoDto.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'lastMessage', (InstantMessageDto, InstantMessageDto.thrift_spec), None, ), # 4
    (5, TType.I32, 'unreadChatMessagesCount', None, None, ), # 5
    (6, TType.I32, 'unreadDealMessagesCount', None, None, ), # 6
    (7, TType.I32, 'unreadChatsCount', None, None, ), # 7
    (8, TType.I32, 'unreadDealsCount', None, None, ), # 8
    (9, TType.STRUCT, 'marker', (PaginationMarkerDto, PaginationMarkerDto.thrift_spec), None, ), # 9
  )

  def __init__(self, opponentId=None, lastDialog=None, lastDeal=None, lastMessage=None, unreadChatMessagesCount=None, unreadDealMessagesCount=None, unreadChatsCount=None, unreadDealsCount=None, marker=None,):
    self.opponentId = opponentId
    self.lastDialog = lastDialog
    self.lastDeal = lastDeal
    self.lastMessage = lastMessage
    self.unreadChatMessagesCount = unreadChatMessagesCount
    self.unreadDealMessagesCount = unreadDealMessagesCount
    self.unreadChatsCount = unreadChatsCount
    self.unreadDealsCount = unreadDealsCount
    self.marker = marker

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.opponentId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.lastDialog = DialogInfoDto()
          self.lastDialog.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.lastDeal = DealInfoDto()
          self.lastDeal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.lastMessage = InstantMessageDto()
          self.lastMessage.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.unreadChatMessagesCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.unreadDealMessagesCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.unreadChatsCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.unreadDealsCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.marker = PaginationMarkerDto()
          self.marker.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UserConversationInfo')
    if self.opponentId is not None:
      oprot.writeFieldBegin('opponentId', TType.I32, 1)
      oprot.writeI32(self.opponentId)
      oprot.writeFieldEnd()
    if self.lastDialog is not None:
      oprot.writeFieldBegin('lastDialog', TType.STRUCT, 2)
      self.lastDialog.write(oprot)
      oprot.writeFieldEnd()
    if self.lastDeal is not None:
      oprot.writeFieldBegin('lastDeal', TType.STRUCT, 3)
      self.lastDeal.write(oprot)
      oprot.writeFieldEnd()
    if self.lastMessage is not None:
      oprot.writeFieldBegin('lastMessage', TType.STRUCT, 4)
      self.lastMessage.write(oprot)
      oprot.writeFieldEnd()
    if self.unreadChatMessagesCount is not None:
      oprot.writeFieldBegin('unreadChatMessagesCount', TType.I32, 5)
      oprot.writeI32(self.unreadChatMessagesCount)
      oprot.writeFieldEnd()
    if self.unreadDealMessagesCount is not None:
      oprot.writeFieldBegin('unreadDealMessagesCount', TType.I32, 6)
      oprot.writeI32(self.unreadDealMessagesCount)
      oprot.writeFieldEnd()
    if self.unreadChatsCount is not None:
      oprot.writeFieldBegin('unreadChatsCount', TType.I32, 7)
      oprot.writeI32(self.unreadChatsCount)
      oprot.writeFieldEnd()
    if self.unreadDealsCount is not None:
      oprot.writeFieldBegin('unreadDealsCount', TType.I32, 8)
      oprot.writeI32(self.unreadDealsCount)
      oprot.writeFieldEnd()
    if self.marker is not None:
      oprot.writeFieldBegin('marker', TType.STRUCT, 9)
      self.marker.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnreadReportDto:
  """
  Attributes:
   - unreadChatMessagesCount
   - unreadChatsCount
   - unreadDealMessagesCount
   - unreadDealsCount
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'unreadChatMessagesCount', None, None, ), # 1
    (2, TType.I32, 'unreadChatsCount', None, None, ), # 2
    (3, TType.I32, 'unreadDealMessagesCount', None, None, ), # 3
    (4, TType.I32, 'unreadDealsCount', None, None, ), # 4
  )

  def __init__(self, unreadChatMessagesCount=None, unreadChatsCount=None, unreadDealMessagesCount=None, unreadDealsCount=None,):
    self.unreadChatMessagesCount = unreadChatMessagesCount
    self.unreadChatsCount = unreadChatsCount
    self.unreadDealMessagesCount = unreadDealMessagesCount
    self.unreadDealsCount = unreadDealsCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.unreadChatMessagesCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.unreadChatsCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.unreadDealMessagesCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.unreadDealsCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnreadReportDto')
    if self.unreadChatMessagesCount is not None:
      oprot.writeFieldBegin('unreadChatMessagesCount', TType.I32, 1)
      oprot.writeI32(self.unreadChatMessagesCount)
      oprot.writeFieldEnd()
    if self.unreadChatsCount is not None:
      oprot.writeFieldBegin('unreadChatsCount', TType.I32, 2)
      oprot.writeI32(self.unreadChatsCount)
      oprot.writeFieldEnd()
    if self.unreadDealMessagesCount is not None:
      oprot.writeFieldBegin('unreadDealMessagesCount', TType.I32, 3)
      oprot.writeI32(self.unreadDealMessagesCount)
      oprot.writeFieldEnd()
    if self.unreadDealsCount is not None:
      oprot.writeFieldBegin('unreadDealsCount', TType.I32, 4)
      oprot.writeI32(self.unreadDealsCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FilterByUserRequest:
  """
  Attributes:
   - ownerId
   - limit
   - offset
   - marker
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'ownerId', None, None, ), # 1
    (2, TType.I32, 'limit', None, None, ), # 2
    (3, TType.I32, 'offset', None, None, ), # 3
    (4, TType.STRUCT, 'marker', (PaginationMarkerDto, PaginationMarkerDto.thrift_spec), None, ), # 4
  )

  def __init__(self, ownerId=None, limit=None, offset=None, marker=None,):
    self.ownerId = ownerId
    self.limit = limit
    self.offset = offset
    self.marker = marker

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.ownerId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.limit = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.offset = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.marker = PaginationMarkerDto()
          self.marker.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FilterByUserRequest')
    if self.ownerId is not None:
      oprot.writeFieldBegin('ownerId', TType.I32, 1)
      oprot.writeI32(self.ownerId)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 2)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I32, 3)
      oprot.writeI32(self.offset)
      oprot.writeFieldEnd()
    if self.marker is not None:
      oprot.writeFieldBegin('marker', TType.STRUCT, 4)
      self.marker.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WareInfo:
  """
  Attributes:
   - wareId
   - unreadMessages
   - totalDealsCount
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'wareId', None, None, ), # 1
    (2, TType.I32, 'unreadMessages', None, None, ), # 2
    (3, TType.I32, 'totalDealsCount', None, None, ), # 3
  )

  def __init__(self, wareId=None, unreadMessages=None, totalDealsCount=None,):
    self.wareId = wareId
    self.unreadMessages = unreadMessages
    self.totalDealsCount = totalDealsCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.wareId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.unreadMessages = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.totalDealsCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WareInfo')
    if self.wareId is not None:
      oprot.writeFieldBegin('wareId', TType.STRING, 1)
      oprot.writeString(self.wareId)
      oprot.writeFieldEnd()
    if self.unreadMessages is not None:
      oprot.writeFieldBegin('unreadMessages', TType.I32, 2)
      oprot.writeI32(self.unreadMessages)
      oprot.writeFieldEnd()
    if self.totalDealsCount is not None:
      oprot.writeFieldBegin('totalDealsCount', TType.I32, 3)
      oprot.writeI32(self.totalDealsCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MessagesReport:
  """
  Сводный отчет по всем сделкам и чатам. Изначально создан для главной страницы в мобильном приложении


  Attributes:
   - unreadMessages
   - wares
   - marker
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'unreadMessages', (UnreadReportDto, UnreadReportDto.thrift_spec), None, ), # 1
    (2, TType.LIST, 'wares', (TType.STRUCT,(WareInfo, WareInfo.thrift_spec)), None, ), # 2
    (3, TType.STRUCT, 'marker', (PaginationMarkerDto, PaginationMarkerDto.thrift_spec), None, ), # 3
  )

  def __init__(self, unreadMessages=None, wares=None, marker=None,):
    self.unreadMessages = unreadMessages
    self.wares = wares
    self.marker = marker

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.unreadMessages = UnreadReportDto()
          self.unreadMessages.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.wares = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = WareInfo()
            _elem40.read(iprot)
            self.wares.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.marker = PaginationMarkerDto()
          self.marker.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MessagesReport')
    if self.unreadMessages is not None:
      oprot.writeFieldBegin('unreadMessages', TType.STRUCT, 1)
      self.unreadMessages.write(oprot)
      oprot.writeFieldEnd()
    if self.wares is not None:
      oprot.writeFieldBegin('wares', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.wares))
      for iter41 in self.wares:
        iter41.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.marker is not None:
      oprot.writeFieldBegin('marker', TType.STRUCT, 3)
      self.marker.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UserDealInfo:
  """
  Информация по сделкам пользователя


  Attributes:
   - deal
   - lastMessage
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'deal', (DealInfoDto, DealInfoDto.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'lastMessage', (InstantMessageDto, InstantMessageDto.thrift_spec), None, ), # 2
  )

  def __init__(self, deal=None, lastMessage=None,):
    self.deal = deal
    self.lastMessage = lastMessage

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.deal = DealInfoDto()
          self.deal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.lastMessage = InstantMessageDto()
          self.lastMessage.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UserDealInfo')
    if self.deal is not None:
      oprot.writeFieldBegin('deal', TType.STRUCT, 1)
      self.deal.write(oprot)
      oprot.writeFieldEnd()
    if self.lastMessage is not None:
      oprot.writeFieldBegin('lastMessage', TType.STRUCT, 2)
      self.lastMessage.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UserDealsDto:
  """
  Attributes:
   - deals
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'deals', (TType.STRUCT,(UserDealInfo, UserDealInfo.thrift_spec)), None, ), # 1
  )

  def __init__(self, deals=None,):
    self.deals = deals

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.deals = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = UserDealInfo()
            _elem47.read(iprot)
            self.deals.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UserDealsDto')
    if self.deals is not None:
      oprot.writeFieldBegin('deals', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.deals))
      for iter48 in self.deals:
        iter48.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UserDialogInfo:
  """
  Attributes:
   - dialog
   - lastMessage
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'dialog', (DialogInfoDto, DialogInfoDto.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'lastMessage', (InstantMessageDto, InstantMessageDto.thrift_spec), None, ), # 2
  )

  def __init__(self, dialog=None, lastMessage=None,):
    self.dialog = dialog
    self.lastMessage = lastMessage

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.dialog = DialogInfoDto()
          self.dialog.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.lastMessage = InstantMessageDto()
          self.lastMessage.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UserDialogInfo')
    if self.dialog is not None:
      oprot.writeFieldBegin('dialog', TType.STRUCT, 1)
      self.dialog.write(oprot)
      oprot.writeFieldEnd()
    if self.lastMessage is not None:
      oprot.writeFieldBegin('lastMessage', TType.STRUCT, 2)
      self.lastMessage.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UserDialogsDto:
  """
  Attributes:
   - dialogs
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'dialogs', (TType.STRUCT,(UserDialogInfo, UserDialogInfo.thrift_spec)), None, ), # 1
  )

  def __init__(self, dialogs=None,):
    self.dialogs = dialogs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.dialogs = []
          (_etype52, _size49) = iprot.readListBegin()
          for _i53 in xrange(_size49):
            _elem54 = UserDialogInfo()
            _elem54.read(iprot)
            self.dialogs.append(_elem54)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UserDialogsDto')
    if self.dialogs is not None:
      oprot.writeFieldBegin('dialogs', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.dialogs))
      for iter55 in self.dialogs:
        iter55.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UserDealsRequestDto:
  """
   * Запрос на получение всех сделок по товару
  *

  Attributes:
   - ownerId: Обязательное поле
   - wareId: Обязательное поле
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'ownerId', None, None, ), # 1
    (2, TType.STRING, 'wareId', None, None, ), # 2
  )

  def __init__(self, ownerId=None, wareId=None,):
    self.ownerId = ownerId
    self.wareId = wareId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.ownerId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.wareId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UserDealsRequestDto')
    if self.ownerId is not None:
      oprot.writeFieldBegin('ownerId', TType.I32, 1)
      oprot.writeI32(self.ownerId)
      oprot.writeFieldEnd()
    if self.wareId is not None:
      oprot.writeFieldBegin('wareId', TType.STRING, 2)
      oprot.writeString(self.wareId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SendMessageException(TException):
  """
   * Эксепшн возникает если при посылке сообщения произошла ошибка
  *

  Attributes:
   - status:  * Статус ошибки
  *
   - reason:  * Причина - расширенное описание ошибки (опционально)
  *
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'status', None, None, ), # 1
    (2, TType.STRING, 'reason', None, None, ), # 2
  )

  def __init__(self, status=None, reason=None,):
    self.status = status
    self.reason = reason

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.status = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.reason = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SendMessageException')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 1)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.reason is not None:
      oprot.writeFieldBegin('reason', TType.STRING, 2)
      oprot.writeString(self.reason)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DialogException(TException):
  """
  Attributes:
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'status', None, None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.status = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DialogException')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 1)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
