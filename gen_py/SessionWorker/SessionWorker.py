# -*- coding: utf-8 -*-
#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from gen_py import Exceptions
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def initSession(self, sessionRequest):
    """
    Создает новую сессию.
    В sessionRequest'е можно прописать данные первого контекста.
    В sessionRequest'e не должно быть проставлено sessionId.


    Parameters:
     - sessionRequest
    """
    pass

  def initContext(self, contextRequest):
    """
    Создает на основе переданных данных новый контекст для указанной сессии.
    Для каждой сессии может быть только один активный контекст каждого типа.
    При попытке создать дублирующийся контекст будет выброшено исключение.
    В contextRequest'e должен быть проставлен sessionId.


    Parameters:
     - contextRequest
    """
    pass

  def getSessionById(self, sessionId, onlyActive):
    """
    Возвращает сессию по ID. Сессия включает все свои контексты.
    Если onlyActive == true, возвращаются только активные контексты.


    Parameters:
     - sessionId
     - onlyActive
    """
    pass

  def getContextForSession(self, sessionId, contextType, onlyActive):
    """
    Возвращает контекст данного типа для данной сессии.
    Если onlyActive == true, контекст будет возвращен только если он активен.


    Parameters:
     - sessionId
     - contextType
     - onlyActive
    """
    pass

  def getContextById(self, contextId, onlyActive):
    """
    Возвращает контекст по его ID.
    Если onlyActive == true, контекст будет возвращен только если он активен.
    Если контекст активен и refresh == true, его lastAccessTimestamp и expirationTimestamp будут обновлены.


    Parameters:
     - contextId
     - onlyActive
    """
    pass

  def replaceContextData(self, contextId, newContextData):
    """
    Заменяет всю contextData данного контекста на новую. Возвращает новое состояние контекста.
    Все старые значения затираются. Эквивалентно oldData = newData;
    Если значение не изменилось, контекст не рефрешится.


    Parameters:
     - contextId
     - newContextData
    """
    pass

  def replaceContextsData(self, contextsToReplace):
    """
    Заменяет всю contextData указанных контекстов на новые. См. replaceContextData().


    Parameters:
     - contextsToReplace
    """
    pass

  def invalidateContext(self, contextId):
    """
    Инвалидирует данный контекст. Контекст помечается как REVOKED.
    Если контекст уже был REVOKED, ничего не делает.


    Parameters:
     - contextId
    """
    pass

  def invalidateSession(self, sessionId):
    """
    Инвалидирует все активные контексты сессии.


    Parameters:
     - sessionId
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def initSession(self, sessionRequest):
    """
    Создает новую сессию.
    В sessionRequest'е можно прописать данные первого контекста.
    В sessionRequest'e не должно быть проставлено sessionId.


    Parameters:
     - sessionRequest
    """
    self.send_initSession(sessionRequest)
    return self.recv_initSession()

  def send_initSession(self, sessionRequest):
    self._oprot.writeMessageBegin('initSession', TMessageType.CALL, self._seqid)
    args = initSession_args()
    args.sessionRequest = sessionRequest
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_initSession(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = initSession_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.uEx is not None:
      raise result.uEx
    if result.bEx is not None:
      raise result.bEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "initSession failed: unknown result");

  def initContext(self, contextRequest):
    """
    Создает на основе переданных данных новый контекст для указанной сессии.
    Для каждой сессии может быть только один активный контекст каждого типа.
    При попытке создать дублирующийся контекст будет выброшено исключение.
    В contextRequest'e должен быть проставлен sessionId.


    Parameters:
     - contextRequest
    """
    self.send_initContext(contextRequest)
    return self.recv_initContext()

  def send_initContext(self, contextRequest):
    self._oprot.writeMessageBegin('initContext', TMessageType.CALL, self._seqid)
    args = initContext_args()
    args.contextRequest = contextRequest
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_initContext(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = initContext_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.uEx is not None:
      raise result.uEx
    if result.bEx is not None:
      raise result.bEx
    if result.nEx is not None:
      raise result.nEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "initContext failed: unknown result");

  def getSessionById(self, sessionId, onlyActive):
    """
    Возвращает сессию по ID. Сессия включает все свои контексты.
    Если onlyActive == true, возвращаются только активные контексты.


    Parameters:
     - sessionId
     - onlyActive
    """
    self.send_getSessionById(sessionId, onlyActive)
    return self.recv_getSessionById()

  def send_getSessionById(self, sessionId, onlyActive):
    self._oprot.writeMessageBegin('getSessionById', TMessageType.CALL, self._seqid)
    args = getSessionById_args()
    args.sessionId = sessionId
    args.onlyActive = onlyActive
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getSessionById(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getSessionById_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.uEx is not None:
      raise result.uEx
    if result.bEx is not None:
      raise result.bEx
    if result.nEx is not None:
      raise result.nEx
    if result.nullEx is not None:
      raise result.nullEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSessionById failed: unknown result");

  def getContextForSession(self, sessionId, contextType, onlyActive):
    """
    Возвращает контекст данного типа для данной сессии.
    Если onlyActive == true, контекст будет возвращен только если он активен.


    Parameters:
     - sessionId
     - contextType
     - onlyActive
    """
    self.send_getContextForSession(sessionId, contextType, onlyActive)
    return self.recv_getContextForSession()

  def send_getContextForSession(self, sessionId, contextType, onlyActive):
    self._oprot.writeMessageBegin('getContextForSession', TMessageType.CALL, self._seqid)
    args = getContextForSession_args()
    args.sessionId = sessionId
    args.contextType = contextType
    args.onlyActive = onlyActive
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getContextForSession(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getContextForSession_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.uEx is not None:
      raise result.uEx
    if result.bEx is not None:
      raise result.bEx
    if result.nEx is not None:
      raise result.nEx
    if result.nullEx is not None:
      raise result.nullEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getContextForSession failed: unknown result");

  def getContextById(self, contextId, onlyActive):
    """
    Возвращает контекст по его ID.
    Если onlyActive == true, контекст будет возвращен только если он активен.
    Если контекст активен и refresh == true, его lastAccessTimestamp и expirationTimestamp будут обновлены.


    Parameters:
     - contextId
     - onlyActive
    """
    self.send_getContextById(contextId, onlyActive)
    return self.recv_getContextById()

  def send_getContextById(self, contextId, onlyActive):
    self._oprot.writeMessageBegin('getContextById', TMessageType.CALL, self._seqid)
    args = getContextById_args()
    args.contextId = contextId
    args.onlyActive = onlyActive
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getContextById(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getContextById_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.uEx is not None:
      raise result.uEx
    if result.bEx is not None:
      raise result.bEx
    if result.nEx is not None:
      raise result.nEx
    if result.nullEx is not None:
      raise result.nullEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getContextById failed: unknown result");

  def replaceContextData(self, contextId, newContextData):
    """
    Заменяет всю contextData данного контекста на новую. Возвращает новое состояние контекста.
    Все старые значения затираются. Эквивалентно oldData = newData;
    Если значение не изменилось, контекст не рефрешится.


    Parameters:
     - contextId
     - newContextData
    """
    self.send_replaceContextData(contextId, newContextData)
    self.recv_replaceContextData()

  def send_replaceContextData(self, contextId, newContextData):
    self._oprot.writeMessageBegin('replaceContextData', TMessageType.CALL, self._seqid)
    args = replaceContextData_args()
    args.contextId = contextId
    args.newContextData = newContextData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_replaceContextData(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = replaceContextData_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.uEx is not None:
      raise result.uEx
    if result.bEx is not None:
      raise result.bEx
    if result.nEx is not None:
      raise result.nEx
    return

  def replaceContextsData(self, contextsToReplace):
    """
    Заменяет всю contextData указанных контекстов на новые. См. replaceContextData().


    Parameters:
     - contextsToReplace
    """
    self.send_replaceContextsData(contextsToReplace)
    self.recv_replaceContextsData()

  def send_replaceContextsData(self, contextsToReplace):
    self._oprot.writeMessageBegin('replaceContextsData', TMessageType.CALL, self._seqid)
    args = replaceContextsData_args()
    args.contextsToReplace = contextsToReplace
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_replaceContextsData(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = replaceContextsData_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.uEx is not None:
      raise result.uEx
    if result.bEx is not None:
      raise result.bEx
    if result.nEx is not None:
      raise result.nEx
    return

  def invalidateContext(self, contextId):
    """
    Инвалидирует данный контекст. Контекст помечается как REVOKED.
    Если контекст уже был REVOKED, ничего не делает.


    Parameters:
     - contextId
    """
    self.send_invalidateContext(contextId)
    self.recv_invalidateContext()

  def send_invalidateContext(self, contextId):
    self._oprot.writeMessageBegin('invalidateContext', TMessageType.CALL, self._seqid)
    args = invalidateContext_args()
    args.contextId = contextId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_invalidateContext(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = invalidateContext_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.uEx is not None:
      raise result.uEx
    if result.bEx is not None:
      raise result.bEx
    if result.nEx is not None:
      raise result.nEx
    return

  def invalidateSession(self, sessionId):
    """
    Инвалидирует все активные контексты сессии.


    Parameters:
     - sessionId
    """
    self.send_invalidateSession(sessionId)
    self.recv_invalidateSession()

  def send_invalidateSession(self, sessionId):
    self._oprot.writeMessageBegin('invalidateSession', TMessageType.CALL, self._seqid)
    args = invalidateSession_args()
    args.sessionId = sessionId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_invalidateSession(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = invalidateSession_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.uEx is not None:
      raise result.uEx
    if result.bEx is not None:
      raise result.bEx
    if result.nEx is not None:
      raise result.nEx
    return


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["initSession"] = Processor.process_initSession
    self._processMap["initContext"] = Processor.process_initContext
    self._processMap["getSessionById"] = Processor.process_getSessionById
    self._processMap["getContextForSession"] = Processor.process_getContextForSession
    self._processMap["getContextById"] = Processor.process_getContextById
    self._processMap["replaceContextData"] = Processor.process_replaceContextData
    self._processMap["replaceContextsData"] = Processor.process_replaceContextsData
    self._processMap["invalidateContext"] = Processor.process_invalidateContext
    self._processMap["invalidateSession"] = Processor.process_invalidateSession

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_initSession(self, seqid, iprot, oprot):
    args = initSession_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = initSession_result()
    try:
      result.success = self._handler.initSession(args.sessionRequest)
    except Exceptions.ttypes.UnavailableException, uEx:
      result.uEx = uEx
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    oprot.writeMessageBegin("initSession", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_initContext(self, seqid, iprot, oprot):
    args = initContext_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = initContext_result()
    try:
      result.success = self._handler.initContext(args.contextRequest)
    except Exceptions.ttypes.UnavailableException, uEx:
      result.uEx = uEx
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    except Exceptions.ttypes.NoSuchResourceException, nEx:
      result.nEx = nEx
    oprot.writeMessageBegin("initContext", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getSessionById(self, seqid, iprot, oprot):
    args = getSessionById_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getSessionById_result()
    try:
      result.success = self._handler.getSessionById(args.sessionId, args.onlyActive)
    except Exceptions.ttypes.UnavailableException, uEx:
      result.uEx = uEx
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    except Exceptions.ttypes.NoSuchResourceException, nEx:
      result.nEx = nEx
    except Exceptions.ttypes.NullResultException, nullEx:
      result.nullEx = nullEx
    oprot.writeMessageBegin("getSessionById", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getContextForSession(self, seqid, iprot, oprot):
    args = getContextForSession_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getContextForSession_result()
    try:
      result.success = self._handler.getContextForSession(args.sessionId, args.contextType, args.onlyActive)
    except Exceptions.ttypes.UnavailableException, uEx:
      result.uEx = uEx
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    except Exceptions.ttypes.NoSuchResourceException, nEx:
      result.nEx = nEx
    except Exceptions.ttypes.NullResultException, nullEx:
      result.nullEx = nullEx
    oprot.writeMessageBegin("getContextForSession", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getContextById(self, seqid, iprot, oprot):
    args = getContextById_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getContextById_result()
    try:
      result.success = self._handler.getContextById(args.contextId, args.onlyActive)
    except Exceptions.ttypes.UnavailableException, uEx:
      result.uEx = uEx
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    except Exceptions.ttypes.NoSuchResourceException, nEx:
      result.nEx = nEx
    except Exceptions.ttypes.NullResultException, nullEx:
      result.nullEx = nullEx
    oprot.writeMessageBegin("getContextById", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_replaceContextData(self, seqid, iprot, oprot):
    args = replaceContextData_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = replaceContextData_result()
    try:
      self._handler.replaceContextData(args.contextId, args.newContextData)
    except Exceptions.ttypes.UnavailableException, uEx:
      result.uEx = uEx
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    except Exceptions.ttypes.NoSuchResourceException, nEx:
      result.nEx = nEx
    oprot.writeMessageBegin("replaceContextData", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_replaceContextsData(self, seqid, iprot, oprot):
    args = replaceContextsData_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = replaceContextsData_result()
    try:
      self._handler.replaceContextsData(args.contextsToReplace)
    except Exceptions.ttypes.UnavailableException, uEx:
      result.uEx = uEx
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    except Exceptions.ttypes.NoSuchResourceException, nEx:
      result.nEx = nEx
    oprot.writeMessageBegin("replaceContextsData", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_invalidateContext(self, seqid, iprot, oprot):
    args = invalidateContext_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = invalidateContext_result()
    try:
      self._handler.invalidateContext(args.contextId)
    except Exceptions.ttypes.UnavailableException, uEx:
      result.uEx = uEx
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    except Exceptions.ttypes.NoSuchResourceException, nEx:
      result.nEx = nEx
    oprot.writeMessageBegin("invalidateContext", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_invalidateSession(self, seqid, iprot, oprot):
    args = invalidateSession_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = invalidateSession_result()
    try:
      self._handler.invalidateSession(args.sessionId)
    except Exceptions.ttypes.UnavailableException, uEx:
      result.uEx = uEx
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    except Exceptions.ttypes.NoSuchResourceException, nEx:
      result.nEx = nEx
    oprot.writeMessageBegin("invalidateSession", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class initSession_args:
  """
  Attributes:
   - sessionRequest
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'sessionRequest', (SessionContextRequestDto, SessionContextRequestDto.thrift_spec), None, ), # 1
  )

  def __init__(self, sessionRequest=None,):
    self.sessionRequest = sessionRequest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.sessionRequest = SessionContextRequestDto()
          self.sessionRequest.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('initSession_args')
    if self.sessionRequest is not None:
      oprot.writeFieldBegin('sessionRequest', TType.STRUCT, 1)
      self.sessionRequest.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class initSession_result:
  """
  Attributes:
   - success
   - uEx
   - bEx
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SessionDto, SessionDto.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'uEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, uEx=None, bEx=None,):
    self.success = success
    self.uEx = uEx
    self.bEx = bEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SessionDto()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.uEx = Exceptions.ttypes.UnavailableException()
          self.uEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('initSession_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.uEx is not None:
      oprot.writeFieldBegin('uEx', TType.STRUCT, 1)
      self.uEx.write(oprot)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 2)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class initContext_args:
  """
  Attributes:
   - contextRequest
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'contextRequest', (SessionContextRequestDto, SessionContextRequestDto.thrift_spec), None, ), # 1
  )

  def __init__(self, contextRequest=None,):
    self.contextRequest = contextRequest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.contextRequest = SessionContextRequestDto()
          self.contextRequest.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('initContext_args')
    if self.contextRequest is not None:
      oprot.writeFieldBegin('contextRequest', TType.STRUCT, 1)
      self.contextRequest.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class initContext_result:
  """
  Attributes:
   - success
   - uEx
   - bEx
   - nEx
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SessionContextDto, SessionContextDto.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'uEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'nEx', (Exceptions.ttypes.NoSuchResourceException, Exceptions.ttypes.NoSuchResourceException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, uEx=None, bEx=None, nEx=None,):
    self.success = success
    self.uEx = uEx
    self.bEx = bEx
    self.nEx = nEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SessionContextDto()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.uEx = Exceptions.ttypes.UnavailableException()
          self.uEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.nEx = Exceptions.ttypes.NoSuchResourceException()
          self.nEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('initContext_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.uEx is not None:
      oprot.writeFieldBegin('uEx', TType.STRUCT, 1)
      self.uEx.write(oprot)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 2)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    if self.nEx is not None:
      oprot.writeFieldBegin('nEx', TType.STRUCT, 3)
      self.nEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSessionById_args:
  """
  Attributes:
   - sessionId
   - onlyActive
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'sessionId', None, None, ), # 1
    (2, TType.BOOL, 'onlyActive', None, True, ), # 2
  )

  def __init__(self, sessionId=None, onlyActive=thrift_spec[2][4],):
    self.sessionId = sessionId
    self.onlyActive = onlyActive

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.sessionId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.onlyActive = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSessionById_args')
    if self.sessionId is not None:
      oprot.writeFieldBegin('sessionId', TType.STRING, 1)
      oprot.writeString(self.sessionId)
      oprot.writeFieldEnd()
    if self.onlyActive is not None:
      oprot.writeFieldBegin('onlyActive', TType.BOOL, 2)
      oprot.writeBool(self.onlyActive)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSessionById_result:
  """
  Attributes:
   - success
   - uEx
   - bEx
   - nEx
   - nullEx
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SessionDto, SessionDto.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'uEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'nEx', (Exceptions.ttypes.NoSuchResourceException, Exceptions.ttypes.NoSuchResourceException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'nullEx', (Exceptions.ttypes.NullResultException, Exceptions.ttypes.NullResultException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, uEx=None, bEx=None, nEx=None, nullEx=None,):
    self.success = success
    self.uEx = uEx
    self.bEx = bEx
    self.nEx = nEx
    self.nullEx = nullEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SessionDto()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.uEx = Exceptions.ttypes.UnavailableException()
          self.uEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.nEx = Exceptions.ttypes.NoSuchResourceException()
          self.nEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.nullEx = Exceptions.ttypes.NullResultException()
          self.nullEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSessionById_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.uEx is not None:
      oprot.writeFieldBegin('uEx', TType.STRUCT, 1)
      self.uEx.write(oprot)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 2)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    if self.nEx is not None:
      oprot.writeFieldBegin('nEx', TType.STRUCT, 3)
      self.nEx.write(oprot)
      oprot.writeFieldEnd()
    if self.nullEx is not None:
      oprot.writeFieldBegin('nullEx', TType.STRUCT, 4)
      self.nullEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getContextForSession_args:
  """
  Attributes:
   - sessionId
   - contextType
   - onlyActive
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'sessionId', None, None, ), # 1
    (2, TType.STRING, 'contextType', None, None, ), # 2
    (3, TType.BOOL, 'onlyActive', None, True, ), # 3
  )

  def __init__(self, sessionId=None, contextType=None, onlyActive=thrift_spec[3][4],):
    self.sessionId = sessionId
    self.contextType = contextType
    self.onlyActive = onlyActive

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.sessionId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.contextType = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.onlyActive = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getContextForSession_args')
    if self.sessionId is not None:
      oprot.writeFieldBegin('sessionId', TType.STRING, 1)
      oprot.writeString(self.sessionId)
      oprot.writeFieldEnd()
    if self.contextType is not None:
      oprot.writeFieldBegin('contextType', TType.STRING, 2)
      oprot.writeString(self.contextType)
      oprot.writeFieldEnd()
    if self.onlyActive is not None:
      oprot.writeFieldBegin('onlyActive', TType.BOOL, 3)
      oprot.writeBool(self.onlyActive)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getContextForSession_result:
  """
  Attributes:
   - success
   - uEx
   - bEx
   - nEx
   - nullEx
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SessionContextDto, SessionContextDto.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'uEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'nEx', (Exceptions.ttypes.NoSuchResourceException, Exceptions.ttypes.NoSuchResourceException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'nullEx', (Exceptions.ttypes.NullResultException, Exceptions.ttypes.NullResultException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, uEx=None, bEx=None, nEx=None, nullEx=None,):
    self.success = success
    self.uEx = uEx
    self.bEx = bEx
    self.nEx = nEx
    self.nullEx = nullEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SessionContextDto()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.uEx = Exceptions.ttypes.UnavailableException()
          self.uEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.nEx = Exceptions.ttypes.NoSuchResourceException()
          self.nEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.nullEx = Exceptions.ttypes.NullResultException()
          self.nullEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getContextForSession_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.uEx is not None:
      oprot.writeFieldBegin('uEx', TType.STRUCT, 1)
      self.uEx.write(oprot)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 2)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    if self.nEx is not None:
      oprot.writeFieldBegin('nEx', TType.STRUCT, 3)
      self.nEx.write(oprot)
      oprot.writeFieldEnd()
    if self.nullEx is not None:
      oprot.writeFieldBegin('nullEx', TType.STRUCT, 4)
      self.nullEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getContextById_args:
  """
  Attributes:
   - contextId
   - onlyActive
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'contextId', None, None, ), # 1
    (2, TType.BOOL, 'onlyActive', None, True, ), # 2
  )

  def __init__(self, contextId=None, onlyActive=thrift_spec[2][4],):
    self.contextId = contextId
    self.onlyActive = onlyActive

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.contextId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.onlyActive = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getContextById_args')
    if self.contextId is not None:
      oprot.writeFieldBegin('contextId', TType.STRING, 1)
      oprot.writeString(self.contextId)
      oprot.writeFieldEnd()
    if self.onlyActive is not None:
      oprot.writeFieldBegin('onlyActive', TType.BOOL, 2)
      oprot.writeBool(self.onlyActive)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getContextById_result:
  """
  Attributes:
   - success
   - uEx
   - bEx
   - nEx
   - nullEx
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SessionContextDto, SessionContextDto.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'uEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'nEx', (Exceptions.ttypes.NoSuchResourceException, Exceptions.ttypes.NoSuchResourceException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'nullEx', (Exceptions.ttypes.NullResultException, Exceptions.ttypes.NullResultException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, uEx=None, bEx=None, nEx=None, nullEx=None,):
    self.success = success
    self.uEx = uEx
    self.bEx = bEx
    self.nEx = nEx
    self.nullEx = nullEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SessionContextDto()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.uEx = Exceptions.ttypes.UnavailableException()
          self.uEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.nEx = Exceptions.ttypes.NoSuchResourceException()
          self.nEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.nullEx = Exceptions.ttypes.NullResultException()
          self.nullEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getContextById_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.uEx is not None:
      oprot.writeFieldBegin('uEx', TType.STRUCT, 1)
      self.uEx.write(oprot)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 2)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    if self.nEx is not None:
      oprot.writeFieldBegin('nEx', TType.STRUCT, 3)
      self.nEx.write(oprot)
      oprot.writeFieldEnd()
    if self.nullEx is not None:
      oprot.writeFieldBegin('nullEx', TType.STRUCT, 4)
      self.nullEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class replaceContextData_args:
  """
  Attributes:
   - contextId
   - newContextData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'contextId', None, None, ), # 1
    (2, TType.MAP, 'newContextData', (TType.STRING,None,TType.STRING,None), None, ), # 2
  )

  def __init__(self, contextId=None, newContextData=None,):
    self.contextId = contextId
    self.newContextData = newContextData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.contextId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.newContextData = {}
          (_ktype26, _vtype27, _size25 ) = iprot.readMapBegin()
          for _i29 in xrange(_size25):
            _key30 = iprot.readString();
            _val31 = iprot.readString();
            self.newContextData[_key30] = _val31
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('replaceContextData_args')
    if self.contextId is not None:
      oprot.writeFieldBegin('contextId', TType.STRING, 1)
      oprot.writeString(self.contextId)
      oprot.writeFieldEnd()
    if self.newContextData is not None:
      oprot.writeFieldBegin('newContextData', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.newContextData))
      for kiter32,viter33 in self.newContextData.items():
        oprot.writeString(kiter32)
        oprot.writeString(viter33)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class replaceContextData_result:
  """
  Attributes:
   - uEx
   - bEx
   - nEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'uEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'nEx', (Exceptions.ttypes.NoSuchResourceException, Exceptions.ttypes.NoSuchResourceException.thrift_spec), None, ), # 3
  )

  def __init__(self, uEx=None, bEx=None, nEx=None,):
    self.uEx = uEx
    self.bEx = bEx
    self.nEx = nEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.uEx = Exceptions.ttypes.UnavailableException()
          self.uEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.nEx = Exceptions.ttypes.NoSuchResourceException()
          self.nEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('replaceContextData_result')
    if self.uEx is not None:
      oprot.writeFieldBegin('uEx', TType.STRUCT, 1)
      self.uEx.write(oprot)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 2)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    if self.nEx is not None:
      oprot.writeFieldBegin('nEx', TType.STRUCT, 3)
      self.nEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class replaceContextsData_args:
  """
  Attributes:
   - contextsToReplace
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'contextsToReplace', (TType.STRING,None,TType.MAP,(TType.STRING,None,TType.STRING,None)), None, ), # 1
  )

  def __init__(self, contextsToReplace=None,):
    self.contextsToReplace = contextsToReplace

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.contextsToReplace = {}
          (_ktype35, _vtype36, _size34 ) = iprot.readMapBegin()
          for _i38 in xrange(_size34):
            _key39 = iprot.readString();
            _val40 = {}
            (_ktype42, _vtype43, _size41 ) = iprot.readMapBegin()
            for _i45 in xrange(_size41):
              _key46 = iprot.readString();
              _val47 = iprot.readString();
              _val40[_key46] = _val47
            iprot.readMapEnd()
            self.contextsToReplace[_key39] = _val40
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('replaceContextsData_args')
    if self.contextsToReplace is not None:
      oprot.writeFieldBegin('contextsToReplace', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.contextsToReplace))
      for kiter48,viter49 in self.contextsToReplace.items():
        oprot.writeString(kiter48)
        oprot.writeMapBegin(TType.STRING, TType.STRING, len(viter49))
        for kiter50,viter51 in viter49.items():
          oprot.writeString(kiter50)
          oprot.writeString(viter51)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class replaceContextsData_result:
  """
  Attributes:
   - uEx
   - bEx
   - nEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'uEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'nEx', (Exceptions.ttypes.NoSuchResourceException, Exceptions.ttypes.NoSuchResourceException.thrift_spec), None, ), # 3
  )

  def __init__(self, uEx=None, bEx=None, nEx=None,):
    self.uEx = uEx
    self.bEx = bEx
    self.nEx = nEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.uEx = Exceptions.ttypes.UnavailableException()
          self.uEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.nEx = Exceptions.ttypes.NoSuchResourceException()
          self.nEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('replaceContextsData_result')
    if self.uEx is not None:
      oprot.writeFieldBegin('uEx', TType.STRUCT, 1)
      self.uEx.write(oprot)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 2)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    if self.nEx is not None:
      oprot.writeFieldBegin('nEx', TType.STRUCT, 3)
      self.nEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class invalidateContext_args:
  """
  Attributes:
   - contextId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'contextId', None, None, ), # 1
  )

  def __init__(self, contextId=None,):
    self.contextId = contextId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.contextId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('invalidateContext_args')
    if self.contextId is not None:
      oprot.writeFieldBegin('contextId', TType.STRING, 1)
      oprot.writeString(self.contextId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class invalidateContext_result:
  """
  Attributes:
   - uEx
   - bEx
   - nEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'uEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'nEx', (Exceptions.ttypes.NoSuchResourceException, Exceptions.ttypes.NoSuchResourceException.thrift_spec), None, ), # 3
  )

  def __init__(self, uEx=None, bEx=None, nEx=None,):
    self.uEx = uEx
    self.bEx = bEx
    self.nEx = nEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.uEx = Exceptions.ttypes.UnavailableException()
          self.uEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.nEx = Exceptions.ttypes.NoSuchResourceException()
          self.nEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('invalidateContext_result')
    if self.uEx is not None:
      oprot.writeFieldBegin('uEx', TType.STRUCT, 1)
      self.uEx.write(oprot)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 2)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    if self.nEx is not None:
      oprot.writeFieldBegin('nEx', TType.STRUCT, 3)
      self.nEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class invalidateSession_args:
  """
  Attributes:
   - sessionId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'sessionId', None, None, ), # 1
  )

  def __init__(self, sessionId=None,):
    self.sessionId = sessionId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.sessionId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('invalidateSession_args')
    if self.sessionId is not None:
      oprot.writeFieldBegin('sessionId', TType.STRING, 1)
      oprot.writeString(self.sessionId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class invalidateSession_result:
  """
  Attributes:
   - uEx
   - bEx
   - nEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'uEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'nEx', (Exceptions.ttypes.NoSuchResourceException, Exceptions.ttypes.NoSuchResourceException.thrift_spec), None, ), # 3
  )

  def __init__(self, uEx=None, bEx=None, nEx=None,):
    self.uEx = uEx
    self.bEx = bEx
    self.nEx = nEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.uEx = Exceptions.ttypes.UnavailableException()
          self.uEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.nEx = Exceptions.ttypes.NoSuchResourceException()
          self.nEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('invalidateSession_result')
    if self.uEx is not None:
      oprot.writeFieldBegin('uEx', TType.STRUCT, 1)
      self.uEx.write(oprot)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 2)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    if self.nEx is not None:
      oprot.writeFieldBegin('nEx', TType.STRUCT, 3)
      self.nEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
