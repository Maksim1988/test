# -*- coding: utf-8 -*-
#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  """
  АПИ для хранения файлов произвольных форматов и изображений, которые сохраняются с множеством уменьшенных копий для
  показа в раззличных частях приложения.

  """
  def uploadFile(self, file):
    """
    Загрузка в хранилище произвольных бинарных файлов. Загружаемые файлы не могут быть пустыми.
    Возвращается id загруженного файла.


    Parameters:
     - file
    """
    pass

  def getFileUrl(self, fileId):
    """
    Parameters:
     - fileId
    """
    pass

  def getFileUrlBatch(self, fileIds, formats):
    """
    Parameters:
     - fileIds
     - formats
    """
    pass

  def deleteFile(self, fileId):
    """
    Parameters:
     - fileId
    """
    pass

  def uploadPictureWithProfile(self, file, profile):
    """
    Parameters:
     - file
     - profile
    """
    pass

  def refreshPictureWithFormats(self, fileId, force):
    """
    Parameters:
     - fileId
     - force
    """
    pass

  def applyPictureTransformations(self, fileId, transformation):
    """
    Parameters:
     - fileId
     - transformation
    """
    pass

  def refreshAllPictures(self, profile):
    """
    Административное АПИ для перегенерирования всех изображений загруженных с указанным профилем.
    @warning Использовать с осторожностью, запускается тяжёлый процесс без возможности отмены
    и блокировки повторных вызовов.


    Parameters:
     - profile
    """
    pass


class Client(Iface):
  """
  АПИ для хранения файлов произвольных форматов и изображений, которые сохраняются с множеством уменьшенных копий для
  показа в раззличных частях приложения.

  """
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def uploadFile(self, file):
    """
    Загрузка в хранилище произвольных бинарных файлов. Загружаемые файлы не могут быть пустыми.
    Возвращается id загруженного файла.


    Parameters:
     - file
    """
    self.send_uploadFile(file)
    return self.recv_uploadFile()

  def send_uploadFile(self, file):
    self._oprot.writeMessageBegin('uploadFile', TMessageType.CALL, self._seqid)
    args = uploadFile_args()
    args.file = file
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_uploadFile(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = uploadFile_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.bEx is not None:
      raise result.bEx
    if result.naEx is not None:
      raise result.naEx
    if result.fEx is not None:
      raise result.fEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "uploadFile failed: unknown result");

  def getFileUrl(self, fileId):
    """
    Parameters:
     - fileId
    """
    self.send_getFileUrl(fileId)
    return self.recv_getFileUrl()

  def send_getFileUrl(self, fileId):
    self._oprot.writeMessageBegin('getFileUrl', TMessageType.CALL, self._seqid)
    args = getFileUrl_args()
    args.fileId = fileId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getFileUrl(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getFileUrl_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.bEx is not None:
      raise result.bEx
    if result.uEx is not None:
      raise result.uEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getFileUrl failed: unknown result");

  def getFileUrlBatch(self, fileIds, formats):
    """
    Parameters:
     - fileIds
     - formats
    """
    self.send_getFileUrlBatch(fileIds, formats)
    return self.recv_getFileUrlBatch()

  def send_getFileUrlBatch(self, fileIds, formats):
    self._oprot.writeMessageBegin('getFileUrlBatch', TMessageType.CALL, self._seqid)
    args = getFileUrlBatch_args()
    args.fileIds = fileIds
    args.formats = formats
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getFileUrlBatch(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getFileUrlBatch_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.bEx is not None:
      raise result.bEx
    if result.uEx is not None:
      raise result.uEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getFileUrlBatch failed: unknown result");

  def deleteFile(self, fileId):
    """
    Parameters:
     - fileId
    """
    self.send_deleteFile(fileId)
    self.recv_deleteFile()

  def send_deleteFile(self, fileId):
    self._oprot.writeMessageBegin('deleteFile', TMessageType.CALL, self._seqid)
    args = deleteFile_args()
    args.fileId = fileId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteFile(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deleteFile_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.nsrEx is not None:
      raise result.nsrEx
    if result.naEx is not None:
      raise result.naEx
    if result.bEx is not None:
      raise result.bEx
    if result.mEx is not None:
      raise result.mEx
    return

  def uploadPictureWithProfile(self, file, profile):
    """
    Parameters:
     - file
     - profile
    """
    self.send_uploadPictureWithProfile(file, profile)
    return self.recv_uploadPictureWithProfile()

  def send_uploadPictureWithProfile(self, file, profile):
    self._oprot.writeMessageBegin('uploadPictureWithProfile', TMessageType.CALL, self._seqid)
    args = uploadPictureWithProfile_args()
    args.file = file
    args.profile = profile
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_uploadPictureWithProfile(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = uploadPictureWithProfile_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.bEx is not None:
      raise result.bEx
    if result.naEx is not None:
      raise result.naEx
    if result.fEx is not None:
      raise result.fEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "uploadPictureWithProfile failed: unknown result");

  def refreshPictureWithFormats(self, fileId, force):
    """
    Parameters:
     - fileId
     - force
    """
    self.send_refreshPictureWithFormats(fileId, force)
    self.recv_refreshPictureWithFormats()

  def send_refreshPictureWithFormats(self, fileId, force):
    self._oprot.writeMessageBegin('refreshPictureWithFormats', TMessageType.CALL, self._seqid)
    args = refreshPictureWithFormats_args()
    args.fileId = fileId
    args.force = force
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_refreshPictureWithFormats(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = refreshPictureWithFormats_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.nsrEx is not None:
      raise result.nsrEx
    if result.mEx is not None:
      raise result.mEx
    if result.naEx is not None:
      raise result.naEx
    if result.bEx is not None:
      raise result.bEx
    return

  def applyPictureTransformations(self, fileId, transformation):
    """
    Parameters:
     - fileId
     - transformation
    """
    self.send_applyPictureTransformations(fileId, transformation)
    self.recv_applyPictureTransformations()

  def send_applyPictureTransformations(self, fileId, transformation):
    self._oprot.writeMessageBegin('applyPictureTransformations', TMessageType.CALL, self._seqid)
    args = applyPictureTransformations_args()
    args.fileId = fileId
    args.transformation = transformation
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_applyPictureTransformations(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = applyPictureTransformations_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.nsrEx is not None:
      raise result.nsrEx
    if result.mEx is not None:
      raise result.mEx
    if result.naEx is not None:
      raise result.naEx
    if result.bEx is not None:
      raise result.bEx
    return

  def refreshAllPictures(self, profile):
    """
    Административное АПИ для перегенерирования всех изображений загруженных с указанным профилем.
    @warning Использовать с осторожностью, запускается тяжёлый процесс без возможности отмены
    и блокировки повторных вызовов.


    Parameters:
     - profile
    """
    self.send_refreshAllPictures(profile)
    return self.recv_refreshAllPictures()

  def send_refreshAllPictures(self, profile):
    self._oprot.writeMessageBegin('refreshAllPictures', TMessageType.CALL, self._seqid)
    args = refreshAllPictures_args()
    args.profile = profile
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_refreshAllPictures(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = refreshAllPictures_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.bEx is not None:
      raise result.bEx
    if result.mEx is not None:
      raise result.mEx
    if result.naEx is not None:
      raise result.naEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "refreshAllPictures failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["uploadFile"] = Processor.process_uploadFile
    self._processMap["getFileUrl"] = Processor.process_getFileUrl
    self._processMap["getFileUrlBatch"] = Processor.process_getFileUrlBatch
    self._processMap["deleteFile"] = Processor.process_deleteFile
    self._processMap["uploadPictureWithProfile"] = Processor.process_uploadPictureWithProfile
    self._processMap["refreshPictureWithFormats"] = Processor.process_refreshPictureWithFormats
    self._processMap["applyPictureTransformations"] = Processor.process_applyPictureTransformations
    self._processMap["refreshAllPictures"] = Processor.process_refreshAllPictures

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_uploadFile(self, seqid, iprot, oprot):
    args = uploadFile_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = uploadFile_result()
    try:
      result.success = self._handler.uploadFile(args.file)
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    except Exceptions.ttypes.UnavailableException, naEx:
      result.naEx = naEx
    except FileUploadException, fEx:
      result.fEx = fEx
    oprot.writeMessageBegin("uploadFile", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getFileUrl(self, seqid, iprot, oprot):
    args = getFileUrl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getFileUrl_result()
    try:
      result.success = self._handler.getFileUrl(args.fileId)
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    except Exceptions.ttypes.UnavailableException, uEx:
      result.uEx = uEx
    oprot.writeMessageBegin("getFileUrl", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getFileUrlBatch(self, seqid, iprot, oprot):
    args = getFileUrlBatch_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getFileUrlBatch_result()
    try:
      result.success = self._handler.getFileUrlBatch(args.fileIds, args.formats)
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    except Exceptions.ttypes.UnavailableException, uEx:
      result.uEx = uEx
    oprot.writeMessageBegin("getFileUrlBatch", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteFile(self, seqid, iprot, oprot):
    args = deleteFile_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteFile_result()
    try:
      self._handler.deleteFile(args.fileId)
    except Exceptions.ttypes.NoSuchResourceException, nsrEx:
      result.nsrEx = nsrEx
    except Exceptions.ttypes.UnavailableException, naEx:
      result.naEx = naEx
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    except Exceptions.ttypes.MalformedException, mEx:
      result.mEx = mEx
    oprot.writeMessageBegin("deleteFile", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_uploadPictureWithProfile(self, seqid, iprot, oprot):
    args = uploadPictureWithProfile_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = uploadPictureWithProfile_result()
    try:
      result.success = self._handler.uploadPictureWithProfile(args.file, args.profile)
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    except Exceptions.ttypes.UnavailableException, naEx:
      result.naEx = naEx
    except FileUploadException, fEx:
      result.fEx = fEx
    oprot.writeMessageBegin("uploadPictureWithProfile", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_refreshPictureWithFormats(self, seqid, iprot, oprot):
    args = refreshPictureWithFormats_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = refreshPictureWithFormats_result()
    try:
      self._handler.refreshPictureWithFormats(args.fileId, args.force)
    except Exceptions.ttypes.NoSuchResourceException, nsrEx:
      result.nsrEx = nsrEx
    except Exceptions.ttypes.MalformedException, mEx:
      result.mEx = mEx
    except Exceptions.ttypes.UnavailableException, naEx:
      result.naEx = naEx
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    oprot.writeMessageBegin("refreshPictureWithFormats", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_applyPictureTransformations(self, seqid, iprot, oprot):
    args = applyPictureTransformations_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = applyPictureTransformations_result()
    try:
      self._handler.applyPictureTransformations(args.fileId, args.transformation)
    except Exceptions.ttypes.NoSuchResourceException, nsrEx:
      result.nsrEx = nsrEx
    except Exceptions.ttypes.MalformedException, mEx:
      result.mEx = mEx
    except Exceptions.ttypes.UnavailableException, naEx:
      result.naEx = naEx
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    oprot.writeMessageBegin("applyPictureTransformations", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_refreshAllPictures(self, seqid, iprot, oprot):
    args = refreshAllPictures_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = refreshAllPictures_result()
    try:
      result.success = self._handler.refreshAllPictures(args.profile)
    except Exceptions.ttypes.BadRequestException, bEx:
      result.bEx = bEx
    except Exceptions.ttypes.MalformedException, mEx:
      result.mEx = mEx
    except Exceptions.ttypes.UnavailableException, naEx:
      result.naEx = naEx
    oprot.writeMessageBegin("refreshAllPictures", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class uploadFile_args:
  """
  Attributes:
   - file
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'file', (InputFileDto, InputFileDto.thrift_spec), None, ), # 1
  )

  def __init__(self, file=None,):
    self.file = file

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.file = InputFileDto()
          self.file.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('uploadFile_args')
    if self.file is not None:
      oprot.writeFieldBegin('file', TType.STRUCT, 1)
      self.file.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class uploadFile_result:
  """
  Attributes:
   - success
   - bEx
   - naEx
   - fEx
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'naEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'fEx', (FileUploadException, FileUploadException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, bEx=None, naEx=None, fEx=None,):
    self.success = success
    self.bEx = bEx
    self.naEx = naEx
    self.fEx = fEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.naEx = Exceptions.ttypes.UnavailableException()
          self.naEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.fEx = FileUploadException()
          self.fEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('uploadFile_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 1)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    if self.naEx is not None:
      oprot.writeFieldBegin('naEx', TType.STRUCT, 2)
      self.naEx.write(oprot)
      oprot.writeFieldEnd()
    if self.fEx is not None:
      oprot.writeFieldBegin('fEx', TType.STRUCT, 3)
      self.fEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getFileUrl_args:
  """
  Attributes:
   - fileId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'fileId', (FileRefDto, FileRefDto.thrift_spec), None, ), # 1
  )

  def __init__(self, fileId=None,):
    self.fileId = fileId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.fileId = FileRefDto()
          self.fileId.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getFileUrl_args')
    if self.fileId is not None:
      oprot.writeFieldBegin('fileId', TType.STRUCT, 1)
      self.fileId.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getFileUrl_result:
  """
  Attributes:
   - success
   - bEx
   - uEx
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'uEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, bEx=None, uEx=None,):
    self.success = success
    self.bEx = bEx
    self.uEx = uEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.uEx = Exceptions.ttypes.UnavailableException()
          self.uEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getFileUrl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 1)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    if self.uEx is not None:
      oprot.writeFieldBegin('uEx', TType.STRUCT, 2)
      self.uEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getFileUrlBatch_args:
  """
  Attributes:
   - fileIds
   - formats
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'fileIds', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'formats', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, fileIds=None, formats=None,):
    self.fileIds = fileIds
    self.formats = formats

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.fileIds = []
          (_etype19, _size16) = iprot.readListBegin()
          for _i20 in xrange(_size16):
            _elem21 = iprot.readString();
            self.fileIds.append(_elem21)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.formats = []
          (_etype25, _size22) = iprot.readListBegin()
          for _i26 in xrange(_size22):
            _elem27 = iprot.readString();
            self.formats.append(_elem27)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getFileUrlBatch_args')
    if self.fileIds is not None:
      oprot.writeFieldBegin('fileIds', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.fileIds))
      for iter28 in self.fileIds:
        oprot.writeString(iter28)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.formats is not None:
      oprot.writeFieldBegin('formats', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.formats))
      for iter29 in self.formats:
        oprot.writeString(iter29)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getFileUrlBatch_result:
  """
  Attributes:
   - success
   - bEx
   - uEx
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.MAP,(TType.STRING,None,TType.STRING,None)), None, ), # 0
    (1, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'uEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, bEx=None, uEx=None,):
    self.success = success
    self.bEx = bEx
    self.uEx = uEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype31, _vtype32, _size30 ) = iprot.readMapBegin()
          for _i34 in xrange(_size30):
            _key35 = iprot.readString();
            _val36 = {}
            (_ktype38, _vtype39, _size37 ) = iprot.readMapBegin()
            for _i41 in xrange(_size37):
              _key42 = iprot.readString();
              _val43 = iprot.readString();
              _val36[_key42] = _val43
            iprot.readMapEnd()
            self.success[_key35] = _val36
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.uEx = Exceptions.ttypes.UnavailableException()
          self.uEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getFileUrlBatch_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
      for kiter44,viter45 in self.success.items():
        oprot.writeString(kiter44)
        oprot.writeMapBegin(TType.STRING, TType.STRING, len(viter45))
        for kiter46,viter47 in viter45.items():
          oprot.writeString(kiter46)
          oprot.writeString(viter47)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 1)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    if self.uEx is not None:
      oprot.writeFieldBegin('uEx', TType.STRUCT, 2)
      self.uEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteFile_args:
  """
  Attributes:
   - fileId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'fileId', None, None, ), # 1
  )

  def __init__(self, fileId=None,):
    self.fileId = fileId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.fileId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteFile_args')
    if self.fileId is not None:
      oprot.writeFieldBegin('fileId', TType.STRING, 1)
      oprot.writeString(self.fileId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteFile_result:
  """
  Attributes:
   - nsrEx
   - naEx
   - bEx
   - mEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'nsrEx', (Exceptions.ttypes.NoSuchResourceException, Exceptions.ttypes.NoSuchResourceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'naEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'mEx', (Exceptions.ttypes.MalformedException, Exceptions.ttypes.MalformedException.thrift_spec), None, ), # 4
  )

  def __init__(self, nsrEx=None, naEx=None, bEx=None, mEx=None,):
    self.nsrEx = nsrEx
    self.naEx = naEx
    self.bEx = bEx
    self.mEx = mEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.nsrEx = Exceptions.ttypes.NoSuchResourceException()
          self.nsrEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.naEx = Exceptions.ttypes.UnavailableException()
          self.naEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.mEx = Exceptions.ttypes.MalformedException()
          self.mEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteFile_result')
    if self.nsrEx is not None:
      oprot.writeFieldBegin('nsrEx', TType.STRUCT, 1)
      self.nsrEx.write(oprot)
      oprot.writeFieldEnd()
    if self.naEx is not None:
      oprot.writeFieldBegin('naEx', TType.STRUCT, 2)
      self.naEx.write(oprot)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 3)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    if self.mEx is not None:
      oprot.writeFieldBegin('mEx', TType.STRUCT, 4)
      self.mEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class uploadPictureWithProfile_args:
  """
  Attributes:
   - file
   - profile
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'file', (InputFileDto, InputFileDto.thrift_spec), None, ), # 1
    (2, TType.STRING, 'profile', None, None, ), # 2
  )

  def __init__(self, file=None, profile=None,):
    self.file = file
    self.profile = profile

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.file = InputFileDto()
          self.file.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.profile = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('uploadPictureWithProfile_args')
    if self.file is not None:
      oprot.writeFieldBegin('file', TType.STRUCT, 1)
      self.file.write(oprot)
      oprot.writeFieldEnd()
    if self.profile is not None:
      oprot.writeFieldBegin('profile', TType.STRING, 2)
      oprot.writeString(self.profile)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class uploadPictureWithProfile_result:
  """
  Attributes:
   - success
   - bEx
   - naEx
   - fEx
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'naEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'fEx', (FileUploadException, FileUploadException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, bEx=None, naEx=None, fEx=None,):
    self.success = success
    self.bEx = bEx
    self.naEx = naEx
    self.fEx = fEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.naEx = Exceptions.ttypes.UnavailableException()
          self.naEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.fEx = FileUploadException()
          self.fEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('uploadPictureWithProfile_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 1)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    if self.naEx is not None:
      oprot.writeFieldBegin('naEx', TType.STRUCT, 2)
      self.naEx.write(oprot)
      oprot.writeFieldEnd()
    if self.fEx is not None:
      oprot.writeFieldBegin('fEx', TType.STRUCT, 3)
      self.fEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class refreshPictureWithFormats_args:
  """
  Attributes:
   - fileId
   - force
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'fileId', None, None, ), # 1
    (2, TType.BOOL, 'force', None, None, ), # 2
  )

  def __init__(self, fileId=None, force=None,):
    self.fileId = fileId
    self.force = force

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.fileId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.force = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('refreshPictureWithFormats_args')
    if self.fileId is not None:
      oprot.writeFieldBegin('fileId', TType.STRING, 1)
      oprot.writeString(self.fileId)
      oprot.writeFieldEnd()
    if self.force is not None:
      oprot.writeFieldBegin('force', TType.BOOL, 2)
      oprot.writeBool(self.force)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class refreshPictureWithFormats_result:
  """
  Attributes:
   - nsrEx
   - mEx
   - naEx
   - bEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'nsrEx', (Exceptions.ttypes.NoSuchResourceException, Exceptions.ttypes.NoSuchResourceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'mEx', (Exceptions.ttypes.MalformedException, Exceptions.ttypes.MalformedException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'naEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 4
  )

  def __init__(self, nsrEx=None, mEx=None, naEx=None, bEx=None,):
    self.nsrEx = nsrEx
    self.mEx = mEx
    self.naEx = naEx
    self.bEx = bEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.nsrEx = Exceptions.ttypes.NoSuchResourceException()
          self.nsrEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.mEx = Exceptions.ttypes.MalformedException()
          self.mEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.naEx = Exceptions.ttypes.UnavailableException()
          self.naEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('refreshPictureWithFormats_result')
    if self.nsrEx is not None:
      oprot.writeFieldBegin('nsrEx', TType.STRUCT, 1)
      self.nsrEx.write(oprot)
      oprot.writeFieldEnd()
    if self.mEx is not None:
      oprot.writeFieldBegin('mEx', TType.STRUCT, 2)
      self.mEx.write(oprot)
      oprot.writeFieldEnd()
    if self.naEx is not None:
      oprot.writeFieldBegin('naEx', TType.STRUCT, 3)
      self.naEx.write(oprot)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 4)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class applyPictureTransformations_args:
  """
  Attributes:
   - fileId
   - transformation
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'fileId', None, None, ), # 1
    (2, TType.STRUCT, 'transformation', (FullTransformationDto, FullTransformationDto.thrift_spec), None, ), # 2
  )

  def __init__(self, fileId=None, transformation=None,):
    self.fileId = fileId
    self.transformation = transformation

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.fileId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.transformation = FullTransformationDto()
          self.transformation.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('applyPictureTransformations_args')
    if self.fileId is not None:
      oprot.writeFieldBegin('fileId', TType.STRING, 1)
      oprot.writeString(self.fileId)
      oprot.writeFieldEnd()
    if self.transformation is not None:
      oprot.writeFieldBegin('transformation', TType.STRUCT, 2)
      self.transformation.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class applyPictureTransformations_result:
  """
  Attributes:
   - nsrEx
   - mEx
   - naEx
   - bEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'nsrEx', (Exceptions.ttypes.NoSuchResourceException, Exceptions.ttypes.NoSuchResourceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'mEx', (Exceptions.ttypes.MalformedException, Exceptions.ttypes.MalformedException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'naEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 4
  )

  def __init__(self, nsrEx=None, mEx=None, naEx=None, bEx=None,):
    self.nsrEx = nsrEx
    self.mEx = mEx
    self.naEx = naEx
    self.bEx = bEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.nsrEx = Exceptions.ttypes.NoSuchResourceException()
          self.nsrEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.mEx = Exceptions.ttypes.MalformedException()
          self.mEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.naEx = Exceptions.ttypes.UnavailableException()
          self.naEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('applyPictureTransformations_result')
    if self.nsrEx is not None:
      oprot.writeFieldBegin('nsrEx', TType.STRUCT, 1)
      self.nsrEx.write(oprot)
      oprot.writeFieldEnd()
    if self.mEx is not None:
      oprot.writeFieldBegin('mEx', TType.STRUCT, 2)
      self.mEx.write(oprot)
      oprot.writeFieldEnd()
    if self.naEx is not None:
      oprot.writeFieldBegin('naEx', TType.STRUCT, 3)
      self.naEx.write(oprot)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 4)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class refreshAllPictures_args:
  """
  Attributes:
   - profile
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'profile', None, None, ), # 1
  )

  def __init__(self, profile=None,):
    self.profile = profile

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.profile = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('refreshAllPictures_args')
    if self.profile is not None:
      oprot.writeFieldBegin('profile', TType.STRING, 1)
      oprot.writeString(self.profile)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class refreshAllPictures_result:
  """
  Attributes:
   - success
   - bEx
   - mEx
   - naEx
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (RefreshAllResultDto, RefreshAllResultDto.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'bEx', (Exceptions.ttypes.BadRequestException, Exceptions.ttypes.BadRequestException.thrift_spec), None, ), # 1
    None, # 2
    (3, TType.STRUCT, 'mEx', (Exceptions.ttypes.MalformedException, Exceptions.ttypes.MalformedException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'naEx', (Exceptions.ttypes.UnavailableException, Exceptions.ttypes.UnavailableException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, bEx=None, mEx=None, naEx=None,):
    self.success = success
    self.bEx = bEx
    self.mEx = mEx
    self.naEx = naEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = RefreshAllResultDto()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.bEx = Exceptions.ttypes.BadRequestException()
          self.bEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.mEx = Exceptions.ttypes.MalformedException()
          self.mEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.naEx = Exceptions.ttypes.UnavailableException()
          self.naEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('refreshAllPictures_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.bEx is not None:
      oprot.writeFieldBegin('bEx', TType.STRUCT, 1)
      self.bEx.write(oprot)
      oprot.writeFieldEnd()
    if self.mEx is not None:
      oprot.writeFieldBegin('mEx', TType.STRUCT, 3)
      self.mEx.write(oprot)
      oprot.writeFieldEnd()
    if self.naEx is not None:
      oprot.writeFieldBegin('naEx', TType.STRUCT, 4)
      self.naEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
